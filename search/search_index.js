var __index = {"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"vasp-manager","text":"<p> Automatically run <code>VASP</code> relaxation, static, bulk moduli, or elastic constant calculations </p> <p></p>"},{"location":"about/CHANGELOG.html","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"about/CHANGELOG.html#140-2025-08-12","title":"[1.4.0] - 2025-08-12","text":""},{"location":"about/CHANGELOG.html#added","title":"Added","text":"<ul> <li>Write documentation and deploy as gh-pages</li> <li>Add type hints and type checking</li> </ul>"},{"location":"about/CHANGELOG.html#changed","title":"Changed","text":"<ul> <li>README is simplified and points to the documentation site</li> </ul>"},{"location":"about/CHANGELOG.html#135-2025-08-10","title":"[1.3.5] - 2025-08-10","text":""},{"location":"about/CHANGELOG.html#changed_1","title":"Changed","text":"<ul> <li>Enforce calculation types ordering in VaspManager</li> </ul>"},{"location":"about/CHANGELOG.html#134-2025-08-03","title":"[1.3.4] - 2025-08-03","text":""},{"location":"about/CHANGELOG.html#changed_2","title":"Changed","text":"<ul> <li>Change POSCAR precision from 8 to 16 to avoid symmetry errors associated with floating point errors</li> </ul>"},{"location":"about/CHANGELOG.html#133-2025-04-02","title":"[1.3.3] - 2025-04-02","text":""},{"location":"about/CHANGELOG.html#changed_3","title":"Changed","text":"<ul> <li>Use SPDX license expression for compliance with PEP 639</li> </ul>"},{"location":"about/CHANGELOG.html#132-2025-04-02","title":"[1.3.2] - 2025-04-02","text":""},{"location":"about/CHANGELOG.html#changed_4","title":"Changed","text":"<ul> <li>Use dynamic versioning in pyproject.toml</li> </ul>"},{"location":"about/CHANGELOG.html#131-2025-04-01","title":"[1.3.1] - 2025-04-01","text":""},{"location":"about/CHANGELOG.html#added_1","title":"Added","text":"<ul> <li>Added publish to PyPi github workflow</li> </ul>"},{"location":"about/CHANGELOG.html#130-2025-03-24","title":"[1.3.0] - 2025-03-24","text":""},{"location":"about/CHANGELOG.html#added_2","title":"Added","text":"<ul> <li>Added optional mixing tags (AMIX, BMIX) to INCAR from calc config</li> </ul>"},{"location":"about/CHANGELOG.html#changed_5","title":"Changed","text":"<ul> <li>Updated quest configuration for quest[10,11,12] nodes</li> </ul>"},{"location":"about/CHANGELOG.html#120-2025-03-23","title":"[1.2.0] - 2025-03-23","text":""},{"location":"about/CHANGELOG.html#added_3","title":"Added","text":"<ul> <li>Added oqmd psuedopotentials json, oqmd-settings branch now uses these psuedopotentials by default</li> <li>Added primitive to be passed in calculation manager kwargs</li> <li>Allow custom calculation configs for individual job managers</li> <li>Added sort_by callable for sorting results by keys</li> <li>Allow other filenames for slurm exe and jobid files</li> <li>Added (optional) write tags LCHARG, LWAVE, and LVTOT to calc config</li> <li>Catch sbatch errors with subprocess.check_output()</li> <li>Added ASCII logo to VaspManager init</li> <li>Added international_monoclinic argument to get_pmg_structure_from_poscar</li> </ul>"},{"location":"about/CHANGELOG.html#changed_6","title":"Changed","text":"<ul> <li>Changed vasp.q permissions to executable executable</li> <li>Added newline to end of jobid file</li> <li>Updated property setters in Analyzers</li> <li>Updated github actions versions</li> <li>[BREAKING] ElasticAnalyzer is now a better standalone analyzer, and all of the associated processing of VASP outputs is now in the from_calc_dir method. This makes it easier to use ElasticAnalyzer as a utility if you only have the elastic constants and a structure</li> <li>Updated managers with named loggers. Each manager should now print the material name when logging, which should make things easier to track when using multiprocessing</li> <li>Stopped pinning versions, track pymatgen master instead</li> <li>[BREAKING] Unify path naming conventions. Use _dir for directories and _path for filepaths for clarity</li> </ul>"},{"location":"about/CHANGELOG.html#fixed","title":"Fixed","text":"<ul> <li>Fixed rlx restart behavior if to_rerun is False</li> <li>Fixed spacing in VASP error handling message</li> <li>Fixed github actions coverage</li> <li>Fixed static post-hoc analysis</li> <li>Fixed stopping behavior for better status tracking</li> </ul>"},{"location":"about/CHANGELOG.html#114-2024-01-17","title":"[1.1.4] - 2024-01-17","text":""},{"location":"about/CHANGELOG.html#added_4","title":"Added","text":"<ul> <li>Added ability to run static calculations without a previously existing rlx calculation</li> <li>Added capability to override job preambles/commands by placing a {computer}.yml file in the calculations folder</li> <li>Added capability to override the global calc_config.json by placing a new calc_config.json in a material's calculation mode folder</li> </ul>"},{"location":"about/CHANGELOG.html#changed_7","title":"Changed","text":"<ul> <li>Major update to error handling, including tracking of STOPPED calculations</li> <li>Changed number of cores reserved for memory when hitting out-of-memory errors as well as for new Quest 9+ nodes</li> <li>Changed default VASP settings for elastic calculations in calc_config.json. Convergence testing w.r.t. smearing and KPOINTS is still recommended</li> <li>Allow VaspManager to recognize previously zipped archives (for rlx-coarse or rlx calculations)</li> <li>Removed bulkmod_standalone as a mode and incorporated the behavior into the normal bulkmod manager</li> </ul>"},{"location":"about/CHANGELOG.html#fixed_1","title":"Fixed","text":"<ul> <li>Ensure elastic calculations use a conventional unit cell</li> </ul>"},{"location":"about/CHANGELOG.html#113-2023-10-19","title":"[1.1.3] - 2023-10-19","text":""},{"location":"about/CHANGELOG.html#added_5","title":"Added","text":"<ul> <li>Added the ability to write a KPOINTS file by specifying write_kpoints: true in calc_config.json</li> </ul>"},{"location":"about/CHANGELOG.html#changed_8","title":"Changed","text":"<ul> <li>Major updates to vasp error handling</li> <li>Changed default symprec in calc_config.json</li> <li>When a job fails, double the walltime instead of doubling the number of nodes. This is typically more efficient in terms of total computational cost</li> <li>Made variable names in util functions more explicit</li> </ul>"},{"location":"about/CHANGELOG.html#fixed_2","title":"Fixed","text":"<ul> <li>Fixed error in increasing the walltime upon job failure</li> <li>Made the mpitasks variable uniform in the vasp.q yml files, and fix the improper reference to mpi_tasks</li> <li>Fixed POTCAR path in computing_config.json</li> <li>Fixed error in ElasticManager when the number of displacements &gt;= 100</li> <li>Fixed Quest computing configuration after Quest8 nodes were retired</li> <li>Fixed automatic NBANDS for ElasticManager when the number of available compute cores is greater than \u00be the number of electrons</li> <li>Fixed BulkmodManager symlink creation when the symlink already exists</li> </ul>"},{"location":"about/CHANGELOG.html#112-2023-10-06","title":"[1.1.2] - 2023-10-06","text":""},{"location":"about/CHANGELOG.html#added_6","title":"Added","text":"<ul> <li>Added support for bridges2 in computing_config.json and vasp.q yml templates</li> </ul>"},{"location":"about/CHANGELOG.html#changed_9","title":"Changed","text":"<ul> <li>Use only pyproject.toml instead of setup.py and pyproject.toml</li> <li>Changed LICENSE to .md instead of .txt</li> <li>Changed utility functions (phead, ptail, pgrep) to iterate over lines in the file rather than reading the entire file into memory</li> <li>pot_dict.json is now a symbolic link to enable better support for multiple VASP versions</li> <li>Utilize yml tempaltes for vasp.q creation for easier customizability</li> </ul>"},{"location":"about/LICENSE.html","title":"License","text":"LICENSE.md<pre><code>Copyright 2022-2025 Dale Gaines II\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>vasp_manager<ul> <li>analyzer<ul> <li>bulkmod_analyzer</li> <li>elastic_analyzer</li> </ul> </li> <li>calculation_manager<ul> <li>base</li> <li>bulkmod</li> <li>elastic</li> <li>rlx</li> <li>rlx_coarse</li> <li>static</li> </ul> </li> <li>job_manager</li> <li>types</li> <li>utils</li> <li>vasp_input_creator</li> <li>vasp_manager</li> </ul> </li> </ul>"},{"location":"reference/vasp_manager/job_manager.html","title":"job_manager","text":""},{"location":"reference/vasp_manager/job_manager.html#vasp_manager.job_manager.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/vasp_manager/job_manager.html#vasp_manager.job_manager.JobManager","title":"JobManager","text":"<pre><code>JobManager(\n    calc_dir: WorkingDirectory,\n    exe_name: str = \"vasp.q\",\n    jobid_name: str = \"jobid\",\n    config_dir: SourceDirectory | None = None,\n    manager_name: str = None,\n    ignore_personal_errors: bool = True,\n)\n</code></pre> <p>Handles job submission and status monitoring</p> <p>Parameters:</p> <ul> <li> <code>calc_dir</code>               (<code>WorkingDirectory</code>)           \u2013            <p>base directory of job</p> </li> <li> <code>exe_name</code>               (<code>str</code>, default:                   <code>'vasp.q'</code> )           \u2013            <p>filename for slurm job submission</p> </li> <li> <code>jobid_name</code>               (<code>str</code>, default:                   <code>'jobid'</code> )           \u2013            <p>filename for storing slurm jobid</p> </li> <li> <code>config_dir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>path to directory containing configuration files. If None, use the parent directory of calc_dir</p> </li> <li> <code>manager_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>name for logging purposes</p> </li> <li> <code>ignore_personal_errors</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, ignore job submission errors if on personal computer</p> </li> </ul> Source code in <code>vasp_manager/job_manager.py</code> <pre><code>def __init__(\n    self,\n    calc_dir: WorkingDirectory,\n    exe_name: str = \"vasp.q\",\n    jobid_name: str = \"jobid\",\n    config_dir: SourceDirectory | None = None,\n    manager_name: str = None,\n    ignore_personal_errors: bool = True,\n) -&gt; None:\n    \"\"\"\n    Args:\n        calc_dir: base directory of job\n        exe_name: filename for slurm job submission\n        jobid_name: filename for storing slurm jobid\n        config_dir: path to directory containing configuration files. If\n            None, use the parent directory of calc_dir\n        manager_name: name for logging purposes\n        ignore_personal_errors: if True, ignore job submission errors\n            if on personal computer\n    \"\"\"\n    self.calc_dir = Path(calc_dir)\n    self.config_dir = Path(config_dir) if config_dir else self.calc_dir.parents[1]\n    self.ignore_personal_errors = ignore_personal_errors\n    self.exe_name = exe_name\n    self.jobid_name = jobid_name\n    self.manager_name = manager_name if manager_name else str(self.calc_dir)\n    self._jobid: int\n    self._job_complete: bool\n    self.logger = LoggerAdapter(logging.getLogger(__name__), self.manager_name)\n</code></pre>"},{"location":"reference/vasp_manager/job_manager.html#vasp_manager.job_manager.JobManager.calc_dir","title":"calc_dir  <code>instance-attribute</code>","text":"<pre><code>calc_dir = Path(calc_dir)\n</code></pre>"},{"location":"reference/vasp_manager/job_manager.html#vasp_manager.job_manager.JobManager.computer","title":"computer  <code>cached</code> <code>property</code>","text":"<pre><code>computer: str\n</code></pre>"},{"location":"reference/vasp_manager/job_manager.html#vasp_manager.job_manager.JobManager.computing_config_dict","title":"computing_config_dict  <code>property</code>","text":"<pre><code>computing_config_dict: dict\n</code></pre>"},{"location":"reference/vasp_manager/job_manager.html#vasp_manager.job_manager.JobManager.config_dir","title":"config_dir  <code>instance-attribute</code>","text":"<pre><code>config_dir = Path(config_dir) if config_dir else parents[1]\n</code></pre>"},{"location":"reference/vasp_manager/job_manager.html#vasp_manager.job_manager.JobManager.exe_name","title":"exe_name  <code>instance-attribute</code>","text":"<pre><code>exe_name = exe_name\n</code></pre>"},{"location":"reference/vasp_manager/job_manager.html#vasp_manager.job_manager.JobManager.ignore_personal_errors","title":"ignore_personal_errors  <code>instance-attribute</code>","text":"<pre><code>ignore_personal_errors = ignore_personal_errors\n</code></pre>"},{"location":"reference/vasp_manager/job_manager.html#vasp_manager.job_manager.JobManager.job_complete","title":"job_complete  <code>property</code>","text":"<pre><code>job_complete: bool\n</code></pre>"},{"location":"reference/vasp_manager/job_manager.html#vasp_manager.job_manager.JobManager.job_exists","title":"job_exists  <code>property</code>","text":"<pre><code>job_exists: bool\n</code></pre>"},{"location":"reference/vasp_manager/job_manager.html#vasp_manager.job_manager.JobManager.jobid","title":"jobid  <code>property</code> <code>writable</code>","text":"<pre><code>jobid: int\n</code></pre>"},{"location":"reference/vasp_manager/job_manager.html#vasp_manager.job_manager.JobManager.jobid_name","title":"jobid_name  <code>instance-attribute</code>","text":"<pre><code>jobid_name = jobid_name\n</code></pre>"},{"location":"reference/vasp_manager/job_manager.html#vasp_manager.job_manager.JobManager.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = LoggerAdapter(getLogger(__name__), manager_name)\n</code></pre>"},{"location":"reference/vasp_manager/job_manager.html#vasp_manager.job_manager.JobManager.manager_name","title":"manager_name  <code>instance-attribute</code>","text":"<pre><code>manager_name = (\n    manager_name if manager_name else str(calc_dir)\n)\n</code></pre>"},{"location":"reference/vasp_manager/job_manager.html#vasp_manager.job_manager.JobManager.mode","title":"mode  <code>cached</code> <code>property</code>","text":"<pre><code>mode: str\n</code></pre>"},{"location":"reference/vasp_manager/job_manager.html#vasp_manager.job_manager.JobManager.user_id","title":"user_id  <code>cached</code> <code>property</code>","text":"<pre><code>user_id: str\n</code></pre>"},{"location":"reference/vasp_manager/job_manager.html#vasp_manager.job_manager.JobManager.submit_job","title":"submit_job","text":"<pre><code>submit_job() -&gt; bool\n</code></pre> <p>Submits job, making sure to not make duplicate jobs</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>job_submitted_successfully</p> </li> </ul> Source code in <code>vasp_manager/job_manager.py</code> <pre><code>def submit_job(self) -&gt; bool:\n    \"\"\"\n    Submits job, making sure to not make duplicate jobs\n\n    Returns:\n        job_submitted_successfully\n    \"\"\"\n    if self.job_exists:\n        self.logger.info(f\"{self.mode.upper()} job already exists\")\n        return True\n\n    if \"personal\" in self.computer:\n        msg = (\n            f\"Cannot submit {self.mode.upper()} job for on personal computer\\n\"\n            \"\\tIgnoring job submission...\"\n        )\n        self.logger.debug(msg)\n        return True\n\n    qpath = self.calc_dir / self.exe_name\n    if not qpath.exists():\n        self.logger.info(f\"No {self.exe_name} file in {self.calc_dir}\")\n        # return False here instead of catching an exception\n        # This enables job resubmission by letting the calling function\n        # know that the calculation needs to be restarted\n        return False\n\n    submission_call = f\"sbatch {self.exe_name}\"\n    with change_directory(self.calc_dir):\n        submission_call_output = (\n            subprocess.check_output(submission_call, shell=True)\n            .decode(\"utf-8\")\n            .strip()\n        )\n        jobid = submission_call_output.split(\" \")[3]\n        self.jobid = jobid\n        with open(self.jobid_name, \"w+\") as fw:\n            fw.write(f\"{jobid}\\n\")\n    self.logger.info(f\"Submitted job {jobid}\")\n    return True\n</code></pre>"},{"location":"reference/vasp_manager/types.html","title":"types","text":""},{"location":"reference/vasp_manager/types.html#vasp_manager.types.CalculationManager","title":"CalculationManager  <code>module-attribute</code>","text":"<pre><code>CalculationManager: TypeAlias = (\n    BulkmodCalculationManager\n    | ElasticCalculationManager\n    | RlxCalculationManager\n    | RlxCoarseCalculationManager\n    | StaticCalculationManager\n)\n</code></pre>"},{"location":"reference/vasp_manager/types.html#vasp_manager.types.CalculationType","title":"CalculationType  <code>module-attribute</code>","text":"<pre><code>CalculationType = Literal[\n    \"rlx-coarse\", \"rlx\", \"static\", \"bulkmod\", \"elastic\"\n]\n</code></pre>"},{"location":"reference/vasp_manager/types.html#vasp_manager.types.Filepath","title":"Filepath  <code>module-attribute</code>","text":"<pre><code>Filepath = str | Path\n</code></pre>"},{"location":"reference/vasp_manager/types.html#vasp_manager.types.Filepaths","title":"Filepaths  <code>module-attribute</code>","text":"<pre><code>Filepaths = list[Path]\n</code></pre>"},{"location":"reference/vasp_manager/types.html#vasp_manager.types.Floating","title":"Floating  <code>module-attribute</code>","text":"<pre><code>Floating = float | floating\n</code></pre>"},{"location":"reference/vasp_manager/types.html#vasp_manager.types.SourceDirectory","title":"SourceDirectory  <code>module-attribute</code>","text":"<pre><code>SourceDirectory = str | Path\n</code></pre>"},{"location":"reference/vasp_manager/types.html#vasp_manager.types.WorkingDirectory","title":"WorkingDirectory  <code>module-attribute</code>","text":"<pre><code>WorkingDirectory = str | Path\n</code></pre>"},{"location":"reference/vasp_manager/utils.html","title":"utils","text":""},{"location":"reference/vasp_manager/utils.html#vasp_manager.utils.LoggerAdapter","title":"LoggerAdapter","text":"<pre><code>LoggerAdapter(\n    logger: Logger, prefix: str, separator: str = \" -- \"\n)\n</code></pre> <p>               Bases: <code>LoggerAdapter</code></p> <p>Logging adapter to add a custom prefix to a Logger</p> Source code in <code>vasp_manager/utils.py</code> <pre><code>def __init__(\n    self,\n    logger: logging.Logger,\n    prefix: str,\n    separator: str = \" -- \",\n):\n    super(LoggerAdapter, self).__init__(logger, {})\n    self.prefix = prefix\n    self.separator = separator\n</code></pre>"},{"location":"reference/vasp_manager/utils.html#vasp_manager.utils.LoggerAdapter.prefix","title":"prefix  <code>instance-attribute</code>","text":"<pre><code>prefix = prefix\n</code></pre>"},{"location":"reference/vasp_manager/utils.html#vasp_manager.utils.LoggerAdapter.separator","title":"separator  <code>instance-attribute</code>","text":"<pre><code>separator = separator\n</code></pre>"},{"location":"reference/vasp_manager/utils.html#vasp_manager.utils.LoggerAdapter.process","title":"process","text":"<pre><code>process(msg, kwargs)\n</code></pre> Source code in <code>vasp_manager/utils.py</code> <pre><code>def process(self, msg, kwargs):\n    return f\"{self.prefix}{self.separator}{msg}\", kwargs\n</code></pre>"},{"location":"reference/vasp_manager/utils.html#vasp_manager.utils.NumpyEncoder","title":"NumpyEncoder","text":"<p>               Bases: <code>JSONEncoder</code></p> <p>Special json encoder for numpy types</p>"},{"location":"reference/vasp_manager/utils.html#vasp_manager.utils.NumpyEncoder.default","title":"default","text":"<pre><code>default(obj)\n</code></pre> Source code in <code>vasp_manager/utils.py</code> <pre><code>def default(self, obj):\n    if isinstance(obj, np.integer):\n        return int(obj)\n    elif isinstance(obj, np.floating):\n        return float(obj)\n    elif isinstance(obj, np.ndarray):\n        return obj.tolist()\n    return json.JSONEncoder.default(self, obj)\n</code></pre>"},{"location":"reference/vasp_manager/utils.html#vasp_manager.utils.change_directory","title":"change_directory","text":"<pre><code>change_directory(new_dir: str | Path)\n</code></pre> Source code in <code>vasp_manager/utils.py</code> <pre><code>@contextmanager\ndef change_directory(new_dir: str | Path):\n    prev_dir = os.getcwd()\n    os.chdir(os.path.expanduser(new_dir))\n    try:\n        yield\n    finally:\n        os.chdir(prev_dir)\n</code></pre>"},{"location":"reference/vasp_manager/utils.html#vasp_manager.utils.get_pmg_structure_from_poscar","title":"get_pmg_structure_from_poscar","text":"<pre><code>get_pmg_structure_from_poscar(\n    poscar_path: Filepath,\n    to_process: bool = True,\n    primitive: bool = True,\n    symprec: float = 0.001,\n    angle_tolerance: float = -1.0,\n    international_monoclinic: bool = False,\n    return_spacegroup: bool = False,\n) -&gt; Structure | tuple[Structure, int]\n</code></pre> <p>Parameters:</p> <ul> <li> <code>poscar_path</code>               (<code>Filepath</code>)           \u2013            <p>path to POSCAR file</p> </li> <li> <code>to_process</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, get standard reduced structure</p> </li> <li> <code>primitive</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, get primitive structure, else get conventional structure</p> </li> <li> <code>symprec</code>               (<code>float</code>, default:                   <code>0.001</code> )           \u2013            <p>symprec for SpacegroupAnalyzer</p> </li> <li> <code>angle_tolerance</code>               (<code>float</code>, default:                   <code>-1.0</code> )           \u2013            <p>angle tolerance for SpacegroupAnalyzer</p> </li> <li> <code>international_monoclinic</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if True, convert to proper international convention such that beta is the non-right angle. WARNING: setting True is not compatible with pymatgen kpaths</p> </li> <li> <code>return_spacegroup</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if True, return spacegroup number</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>structure</code> (              <code>Structure | tuple[Structure, int]</code> )          \u2013            <p>structure from POSCAR</p> </li> </ul> Source code in <code>vasp_manager/utils.py</code> <pre><code>def get_pmg_structure_from_poscar(\n    poscar_path: Filepath,\n    to_process: bool = True,\n    primitive: bool = True,\n    symprec: float = 1e-03,\n    angle_tolerance: float = -1.0,\n    international_monoclinic: bool = False,\n    return_spacegroup: bool = False,\n) -&gt; Structure | tuple[Structure, int]:\n    \"\"\"\n    Args:\n        poscar_path: path to POSCAR file\n        to_process: if True, get standard reduced structure\n        primitive: if True, get primitive structure, else get\n            conventional structure\n        symprec: symprec for SpacegroupAnalyzer\n        angle_tolerance: angle tolerance for SpacegroupAnalyzer\n        international_monoclinic: if True, convert to proper\n            international convention such that beta is the non-right angle.\n            WARNING: setting True is not compatible with pymatgen kpaths\n        return_spacegroup: if True, return spacegroup number\n\n    Returns:\n        structure: structure from POSCAR\n    \"\"\"\n    structure = Structure.from_file(poscar_path)\n    if to_process:\n        sga = SpacegroupAnalyzer(\n            structure, symprec=symprec, angle_tolerance=angle_tolerance\n        )\n        if primitive:\n            structure = sga.get_primitive_standard_structure(\n                international_monoclinic=international_monoclinic\n            )\n        else:\n            structure = sga.get_conventional_standard_structure(\n                international_monoclinic=international_monoclinic\n            )\n        if return_spacegroup:\n            spacegroup = sga.get_space_group_number()\n            return structure, spacegroup\n    return structure\n</code></pre>"},{"location":"reference/vasp_manager/utils.html#vasp_manager.utils.make_potcar_anonymous","title":"make_potcar_anonymous","text":"<pre><code>make_potcar_anonymous(\n    input_file_name: Filepath,\n    output_file_name: Filepath | None = None,\n) -&gt; None\n</code></pre> <p>Replace full POTCAR with only single POTCAR names</p> <p>Parameters:</p> <ul> <li> <code>input_file_name</code>               (<code>Filepath</code>)           \u2013            <p>path of POTCAR file</p> </li> <li> <code>output_file_name</code>               (<code>Filepath | None</code>, default:                   <code>None</code> )           \u2013            <p>path to write anonymized POTCAR. If None, write to the location of input_f_name</p> </li> </ul> Source code in <code>vasp_manager/utils.py</code> <pre><code>def make_potcar_anonymous(\n    input_file_name: Filepath,\n    output_file_name: Filepath | None = None,\n) -&gt; None:\n    \"\"\"\n    Replace full POTCAR with only single POTCAR names\n\n    Args:\n        input_file_name: path of POTCAR file\n        output_file_name: path to write anonymized POTCAR. If None, write to\n            the location of input_f_name\n    \"\"\"\n    if output_file_name is None:\n        output_file_name = input_file_name\n\n    with open(input_file_name, \"rt\") as fr:\n        full_potcar_text = [line.strip() for line in fr.readlines()]\n    trimmed_potcar_lines = []\n    for line in full_potcar_text:\n        if \"TITEL\" in line:\n            trimmed_potcar_lines.append(line.split(\"=\")[1].strip())\n    trimmed_potcar_string = \"\\n\".join([line for line in trimmed_potcar_lines])\n    with open(output_file_name, \"w+\") as fw:\n        fw.write(trimmed_potcar_string)\n</code></pre>"},{"location":"reference/vasp_manager/utils.html#vasp_manager.utils.pcat","title":"pcat","text":"<pre><code>pcat(file_names: Filepath | list[Filepath]) -&gt; str\n</code></pre> <p>Custom python-only replacement for cat</p> <p>Parameters:</p> <ul> <li> <code>file_names</code>               (<code>Filepath | list[Filepath]</code>)           \u2013            <p>names of files to cat together</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>catted</code> (              <code>str</code> )          \u2013            </li> </ul> Source code in <code>vasp_manager/utils.py</code> <pre><code>def pcat(file_names: Filepath | list[Filepath]) -&gt; str:\n    \"\"\"\n    Custom python-only replacement for cat\n\n    Args:\n        file_names: names of files to cat together\n\n    Returns:\n        catted:\n    \"\"\"\n    file_contents = []\n    if isinstance(file_names, (str, Path)):\n        file_names = [file_names]\n    for file_name in file_names:\n        with open(file_name) as fr:\n            file_content = fr.read()\n        file_contents.append(file_content)\n    catted = \"\".join(file_content for file_content in file_contents)\n    return catted\n</code></pre>"},{"location":"reference/vasp_manager/utils.html#vasp_manager.utils.pgrep","title":"pgrep","text":"<pre><code>pgrep(\n    file_name: Filepath,\n    str_to_grep: str,\n    stop_after_first_match: bool = False,\n    after: int | None = None,\n    as_string: bool = False,\n) -&gt; str | list[str]\n</code></pre> <p>Custom python-only replacement for grep</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>Filepath</code>)           \u2013            <p>path of file</p> </li> <li> <code>str_to_grep</code>               (<code>str</code>)           \u2013            <p>target string</p> </li> <li> <code>stop_after_first_match</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if True, stop after first found instance of str_to_grep</p> </li> <li> <code>after</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>if not None, return {after} lines found after str_to_grep</p> </li> <li> <code>as_string</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if as_string, return a single string, else return splitlines</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>matches</code> (              <code>str | list[str]</code> )          \u2013            </li> </ul> Source code in <code>vasp_manager/utils.py</code> <pre><code>def pgrep(\n    file_name: Filepath,\n    str_to_grep: str,\n    stop_after_first_match: bool = False,\n    after: int | None = None,\n    as_string: bool = False,\n) -&gt; str | list[str]:\n    \"\"\"\n    Custom python-only replacement for grep\n\n    Args:\n        file_name: path of file\n        str_to_grep: target string\n        stop_after_first_match: if True, stop after first found instance of\n            str_to_grep\n        after: if not None, return {after} lines found after str_to_grep\n        as_string: if as_string, return a single string, else return splitlines\n\n    Returns:\n        matches:\n    \"\"\"\n    opener = gzip.open if \".gz\" in str(file_name) else open\n    matches = []\n    line_idx_to_include: set[int] = set()\n    with opener(file_name, \"rt\") as fr:\n        for line_idx, line in enumerate(fr):\n            if str_to_grep in line:\n                matches.append(line.strip(\"\\n\"))\n                if after is not None:\n                    line_idx_to_include.update(range(line_idx + 1, line_idx + after + 1))\n            if line_idx in line_idx_to_include:\n                matches.append(line.strip(\"\\n\"))\n                line_idx_to_include.discard(line_idx)\n            if stop_after_first_match:\n                if len(matches) != 0 and len(line_idx_to_include) == 0:\n                    break\n    if as_string:\n        matches_as_str = \"\\n\".join([line for line in matches])\n    return matches_as_str if as_string else matches\n</code></pre>"},{"location":"reference/vasp_manager/utils.html#vasp_manager.utils.phead","title":"phead","text":"<pre><code>phead(\n    file_name: Filepath,\n    n_head: int = 1,\n    as_string: bool = False,\n) -&gt; str | list[str]\n</code></pre> <p>Custom python-only replacement for head</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>Filepath</code>)           \u2013            <p>path of file</p> </li> <li> <code>n_head</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>n lines to head</p> </li> <li> <code>as_string</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if as_string, return a single string, else return splitlines</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>head</code> (              <code>str | list[str]</code> )          \u2013            </li> </ul> Source code in <code>vasp_manager/utils.py</code> <pre><code>def phead(\n    file_name: Filepath,\n    n_head: int = 1,\n    as_string: bool = False,\n) -&gt; str | list[str]:\n    \"\"\"\n    Custom python-only replacement for head\n\n    Args:\n        file_name: path of file\n        n_head: n lines to head\n        as_string: if as_string, return a single string, else return splitlines\n\n    Returns:\n        head:\n    \"\"\"\n    opener = gzip.open if \".gz\" in str(file_name) else open\n    head = []\n    with opener(file_name, \"rt\") as fr:\n        for i, line in enumerate(fr):\n            if i &lt; n_head:\n                head.append(line.strip(\"\\n\"))\n    if as_string:\n        head_as_str = \"\\n\".join([line for line in head])\n    return head_as_str if as_string else head\n</code></pre>"},{"location":"reference/vasp_manager/utils.html#vasp_manager.utils.ptail","title":"ptail","text":"<pre><code>ptail(\n    file_name: Filepath,\n    n_tail: int = 1,\n    as_string: bool = False,\n) -&gt; str | list[str]\n</code></pre> <p>Custom python-only replacement for grep</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>Filepath</code>)           \u2013            <p>path of file</p> </li> <li> <code>n_tail</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>n lines to tail</p> </li> <li> <code>as_string</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if as_string, return a single string, else return splitlines</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tail</code> (              <code>str | list[str]</code> )          \u2013            </li> </ul> Source code in <code>vasp_manager/utils.py</code> <pre><code>def ptail(\n    file_name: Filepath,\n    n_tail: int = 1,\n    as_string: bool = False,\n) -&gt; str | list[str]:\n    \"\"\"\n    Custom python-only replacement for grep\n\n    Args:\n        file_name: path of file\n        n_tail: n lines to tail\n        as_string: if as_string, return a single string, else return splitlines\n\n    Returns:\n        tail:\n    \"\"\"\n    opener = gzip.open if \".gz\" in str(file_name) else open\n    tail: deque[str] = deque(maxlen=n_tail)\n    with opener(file_name, \"rt\") as fr:\n        for line in fr:\n            tail.append(line.strip(\"\\n\"))\n    if as_string:\n        tail_as_str = \"\\n\".join([line for line in tail])\n    return tail_as_str if as_string else list(tail)\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html","title":"vasp_input_creator","text":""},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator","title":"VaspInputCreator","text":"<pre><code>VaspInputCreator(\n    calc_dir: WorkingDirectory,\n    mode: str,\n    poscar_source_path: Filepath,\n    config_dir: SourceDirectory | None = None,\n    primitive: bool = True,\n    name: str = None,\n    increase_nodes_by_factor: int = 1,\n    increase_walltime_by_factor: int = 1,\n    poscar_significant_figures: int = 16,\n    ncore_per_node_for_memory: int | None = None,\n    use_spin: bool = True,\n)\n</code></pre> <p>Handles VASP file creation</p> <p>Parameters:</p> <ul> <li> <code>calc_dir</code>               (<code>WorkingDirectory</code>)           \u2013            </li> <li> <code>mode</code>               (<code>str</code>)           \u2013            </li> <li> <code>poscar_source_path</code>               (<code>Filepath</code>)           \u2013            </li> <li> <code>config_dir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>primitive</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>increase_nodes_by_factor</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            </li> <li> <code>increase_walltime_by_factor</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            </li> <li> <code>poscar_significant_figures</code>               (<code>int</code>, default:                   <code>16</code> )           \u2013            </li> <li> <code>ncore_per_node_for_memory</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>use_spin</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>pass False to suppress spin polarization</p> </li> </ul> Source code in <code>vasp_manager/vasp_input_creator.py</code> <pre><code>def __init__(\n    self,\n    calc_dir: WorkingDirectory,\n    mode: str,\n    poscar_source_path: Filepath,\n    config_dir: SourceDirectory | None = None,\n    primitive: bool = True,\n    name: str = None,\n    increase_nodes_by_factor: int = 1,\n    increase_walltime_by_factor: int = 1,\n    poscar_significant_figures: int = 16,\n    ncore_per_node_for_memory: int | None = None,\n    use_spin: bool = True,\n) -&gt; None:\n    \"\"\"\n    Args:\n        calc_dir:\n        mode:\n        poscar_source_path:\n        config_dir:\n        primitive:\n        name:\n        increase_nodes_by_factor:\n        increase_walltime_by_factor:\n        poscar_significant_figures:\n        ncore_per_node_for_memory:\n        use_spin: pass False to suppress spin polarization\n    \"\"\"\n    self.calc_dir = Path(calc_dir)\n    self.mode = mode\n    self.poscar_source_path = Path(poscar_source_path)\n    self.config_dir = Path(config_dir) if config_dir else self.calc_dir.parents[1]\n    self.primitive = primitive\n    self.increase_nodes_by_factor = int(increase_nodes_by_factor)\n    self.increase_walltime_by_factor = int(increase_walltime_by_factor)\n    self.name = name if name else self.source_structure.composition.reduced_formula\n    self.poscar_significant_figures = poscar_significant_figures\n    self.ncore_per_node_for_memory = ncore_per_node_for_memory\n    self.use_spin = use_spin\n    self.logger = LoggerAdapter(logging.getLogger(__name__), self.name)\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.calc_config","title":"calc_config  <code>cached</code> <code>property</code>","text":"<pre><code>calc_config: dict\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.calc_dir","title":"calc_dir  <code>instance-attribute</code>","text":"<pre><code>calc_dir = Path(calc_dir)\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.computer","title":"computer  <code>cached</code> <code>property</code>","text":"<pre><code>computer: str\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.computing_config","title":"computing_config  <code>cached</code> <code>property</code>","text":"<pre><code>computing_config: dict\n</code></pre> <p>Dict containing only the computing config for the specified computer</p>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.computing_config_dict","title":"computing_config_dict  <code>cached</code> <code>property</code>","text":"<pre><code>computing_config_dict: dict\n</code></pre> <p>Dict containing all computing configs</p>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.config_dir","title":"config_dir  <code>instance-attribute</code>","text":"<pre><code>config_dir = Path(config_dir) if config_dir else parents[1]\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.d_f_block","title":"d_f_block  <code>cached</code> <code>property</code>","text":"<pre><code>d_f_block: dict\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.hubbards","title":"hubbards  <code>cached</code> <code>property</code>","text":"<pre><code>hubbards: dict\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.incar_template","title":"incar_template  <code>cached</code> <code>property</code>","text":"<pre><code>incar_template: str\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.increase_nodes_by_factor","title":"increase_nodes_by_factor  <code>instance-attribute</code>","text":"<pre><code>increase_nodes_by_factor = int(increase_nodes_by_factor)\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.increase_walltime_by_factor","title":"increase_walltime_by_factor  <code>instance-attribute</code>","text":"<pre><code>increase_walltime_by_factor = int(\n    increase_walltime_by_factor\n)\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = LoggerAdapter(getLogger(__name__), name)\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.mode","title":"mode  <code>instance-attribute</code>","text":"<pre><code>mode = mode\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.n_nodes","title":"n_nodes  <code>cached</code> <code>property</code>","text":"<pre><code>n_nodes: int\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.n_procs","title":"n_procs  <code>cached</code> <code>property</code>","text":"<pre><code>n_procs: int\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.n_procs_used","title":"n_procs_used  <code>cached</code> <code>property</code>","text":"<pre><code>n_procs_used: int\n</code></pre> <p>Total number of actual processors to run VASP, which may be different than the total number of processors requested in SLURM     Typically request all available processors on each node, and then     (optionally) leave some empty for memory or ease of division</p>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = name if name else reduced_formula\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.ncore_per_node_for_memory","title":"ncore_per_node_for_memory  <code>property</code> <code>writable</code>","text":"<pre><code>ncore_per_node_for_memory: int\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.poscar_significant_figures","title":"poscar_significant_figures  <code>instance-attribute</code>","text":"<pre><code>poscar_significant_figures = poscar_significant_figures\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.poscar_source_path","title":"poscar_source_path  <code>instance-attribute</code>","text":"<pre><code>poscar_source_path = Path(poscar_source_path)\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.potcar_dict","title":"potcar_dict  <code>cached</code> <code>property</code>","text":"<pre><code>potcar_dict: dict\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.primitive","title":"primitive  <code>instance-attribute</code>","text":"<pre><code>primitive = primitive\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.q_mapper","title":"q_mapper  <code>cached</code> <code>property</code>","text":"<pre><code>q_mapper: dict\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.source_structure","title":"source_structure  <code>cached</code> <code>property</code>","text":"<pre><code>source_structure: Structure\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.use_spin","title":"use_spin  <code>instance-attribute</code>","text":"<pre><code>use_spin = use_spin\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.create","title":"create","text":"<pre><code>create() -&gt; None\n</code></pre> <p>Make VASP input files</p> Note <p>Don't touch the order! make_incar and make_vaspq rely on the poscar and potcar existing already</p> Source code in <code>vasp_manager/vasp_input_creator.py</code> <pre><code>def create(self) -&gt; None:\n    \"\"\"\n    Make VASP input files\n\n    Note:\n        Don't touch the order! make_incar and make_vaspq rely on the poscar and\n        potcar existing already\n    \"\"\"\n    if not self.calc_dir.exists():\n        self.calc_dir.mkdir()\n    self.make_poscar()\n    self.make_potcar()\n    if \"write_kpoints\" in self.calc_config:\n        if self.calc_config[\"write_kpoints\"]:\n            self.make_kpoints()\n    self.make_incar()\n    self.make_vaspq()\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.make_archive_and_repopulate","title":"make_archive_and_repopulate","text":"<pre><code>make_archive_and_repopulate() -&gt; None\n</code></pre> <p>Make an archive of a VASP calculation and copy back over relevant files</p> Source code in <code>vasp_manager/vasp_input_creator.py</code> <pre><code>def make_archive_and_repopulate(self) -&gt; None:\n    \"\"\"\n    Make an archive of a VASP calculation and copy back over relevant files\n    \"\"\"\n    with change_directory(self.calc_dir):\n        contcar_path = Path(\"CONTCAR\")\n        contcar_exists = contcar_path.exists()\n        if contcar_exists:\n            contcar_is_empty = contcar_path.stat().st_size == 0\n        else:\n            contcar_is_empty = True\n\n        # if CONTCAR is empty, don't make an archive and clean up\n        if contcar_is_empty:\n            all_files = [\n                f\n                for f in Path(\".\").glob(\"*\")\n                if f.is_file() and \"archive\" not in f.name and \"json\" not in f.name\n            ]\n            for f in all_files:\n                os.remove(f)\n        # else, make the archive\n        else:\n            num_previous_archives = len(list(Path(\".\").glob(\"archive*\")))\n            archive_name = Path(f\"archive_{num_previous_archives}\")\n            self.logger.info(f\"Making {archive_name}...\")\n            archive_name.mkdir()\n\n            all_files = [\n                f\n                for f in Path(\".\").glob(\"*\")\n                if f.is_file() and \"archive\" not in f.name and \"json\" not in f.name\n            ]\n            for f in all_files:\n                # add if symlink for testing\n                if f.is_symlink():\n                    f_links_to = f.readlink()\n                    os.remove(f)\n                    shutil.copy2(f_links_to, f)\n                shutil.move(f, archive_name)\n\n    self.create()\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.make_incar","title":"make_incar","text":"<pre><code>make_incar() -&gt; None\n</code></pre> <p>Create and write an INCAR</p> <p>Current kpoints coming from the kspacing tag in the INCAR,     but future versions should include ability to make kpoints from kppra</p> Source code in <code>vasp_manager/vasp_input_creator.py</code> <pre><code>def make_incar(self) -&gt; None:\n    \"\"\"\n    Create and write an INCAR\n\n    Current kpoints coming from the kspacing tag in the INCAR,\n        but future versions should include ability to make kpoints from kppra\n    \"\"\"\n    incar_path = self.calc_dir / \"INCAR\"\n    calc_config = self.calc_config.copy()\n\n    if calc_config[\"ispin\"] not in [1, \"auto\"]:\n        raise RuntimeError(\"ISPIN must be set to 1 or auto\")\n\n    if calc_config[\"hubbards\"] not in [None, False, \"wang\"]:\n        raise RuntimeError(\"hubbards must be set to None, False, or 'wang'\")\n    if calc_config[\"hubbards\"] == \"wang\" and calc_config[\"gga\"] != \"PE\":\n        raise RuntimeError(\"DFT+U is only support for PBE\")\n\n    if calc_config[\"iopt\"] != 0 and calc_config[\"potim\"] != 0:\n        raise RuntimeError(\"To use IOPT != 0, POTIM must be set to 0\")\n\n    composition_dict = self.source_structure.composition.as_dict()\n    # read POTCAR\n    potcar_path = self.calc_dir / \"POTCAR\"\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", category=UserWarning)\n        potcar = Potcar.from_file(potcar_path)\n    n_electrons = 0\n    for potcar_single in potcar:\n        n_electrons += (\n            potcar_single.nelectrons * composition_dict[potcar_single.element]\n        )\n    # make n_bands divisible by NCORE (VASP INCAR tag)\n    # elastic calculation won't run unless NCORE=1\n    if self.mode == \"elastic\":\n        self.computing_config[\"ncore\"] = 1\n    ncore = self.computing_config[\"ncore\"]\n    calc_config[\"ncore\"] = ncore\n    cores_per_group = int(self.n_procs_used / self.calc_config[\"kpar\"])\n    calc_config[\"nbands\"] = np.max(\n        [\n            int(np.ceil(0.75 * n_electrons / ncore) * ncore),\n            cores_per_group,\n        ]\n    )\n    for write_tag in [\"lcharge\", \"lwave\", \"lvtot\"]:\n        calc_config[write_tag] = calc_config.get(write_tag, \".FALSE.\")\n    calc_config[\"amix\"] = calc_config.get(\"amix\", 0.4)\n    calc_config[\"bmix\"] = calc_config.get(\"bmix\", 1.0)\n\n    needs_spin_polarization = self._check_needs_spin_polarization(composition_dict)\n    use_spin_polarization = (\n        needs_spin_polarization and calc_config[\"ispin\"] == \"auto\" and self.use_spin\n    )\n    if use_spin_polarization:\n        ispin = 2\n        magmom_line = self._get_auto_magmom(composition_dict)\n    else:\n        ispin = 1\n\n    needs_dftu = self._check_needs_dftu(calc_config[\"hubbards\"], composition_dict)\n    use_dftu = needs_dftu and calc_config[\"hubbards\"]\n    if use_dftu:\n        lmaxmix = self._get_lmaxmix(composition_dict)\n        lmaxmix_line = f\"LMAXMIX = {lmaxmix}\"\n        ldau_string = self._get_ldau_string(calc_config[\"hubbards\"], composition_dict)\n\n    # Add lines to the incar file\n    incar_tmp = self.incar_template.split(\"\\n\")\n    for i, line in enumerate(incar_tmp):\n        # add extra flags for spin polarization\n        if \"ISPIN\" in line:\n            incar_tmp[i] = f\"ISPIN = {ispin}\"\n            if use_spin_polarization:\n                incar_tmp.insert(i + 1, magmom_line)\n        if \"LVTOT\" in line and use_spin_polarization:\n            lorbit_line = \"LORBIT = 11\"\n            incar_tmp.insert(i + 1, lorbit_line)\n        # add extra flags for DFT+U\n        if \"DFT+U\" in line and use_dftu:\n            incar_tmp.insert(i + 1, lmaxmix_line)\n            incar_tmp.insert(i + 1, ldau_string)\n        # add extra flags for elastic mode\n        if self.mode == \"elastic\":\n            if \"KSPACING\" in line:\n                nfree_line = \"NFREE = {nfree}\"\n                incar_tmp.insert(i + 1, nfree_line)\n    incar_tmp_as_str = \"\\n\".join([line for line in incar_tmp])\n    incar = incar_tmp_as_str.format(**calc_config)\n    self.logger.debug(incar)\n    with open(incar_path, \"w+\") as fw:\n        fw.write(incar)\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.make_kpoints","title":"make_kpoints","text":"<pre><code>make_kpoints() -&gt; None\n</code></pre> Source code in <code>vasp_manager/vasp_input_creator.py</code> <pre><code>def make_kpoints(self) -&gt; None:\n    kpoints_path = self.calc_dir / \"KPOINTS\"\n    kspacing = self.calc_config[\"kspacing\"]\n    reciprocal_lattice = self.source_structure.lattice.reciprocal_lattice\n    abc = np.asarray(reciprocal_lattice.abc)\n    kpoints = [int(k) for k in np.ceil(abc / kspacing)]\n    kpoints_str = \" \".join(str(kpoint) for kpoint in kpoints)\n    kpoints_text = f\"kpoints generated from kspacing={kspacing}\\n\"\n    kpoints_text += \"0\\n\"\n    kpoints_text += \"Gamma\\n\"\n    kpoints_text += f\"{kpoints_str}\\n\"\n    with open(kpoints_path, \"w+\") as fw:\n        fw.write(kpoints_text)\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.make_poscar","title":"make_poscar","text":"<pre><code>make_poscar() -&gt; None\n</code></pre> <p>Create and write a POSCAR</p> Source code in <code>vasp_manager/vasp_input_creator.py</code> <pre><code>def make_poscar(self) -&gt; None:\n    \"\"\"\n    Create and write a POSCAR\n    \"\"\"\n    poscar = Poscar(self.source_structure)\n    poscar_path = self.calc_dir / \"POSCAR\"\n    poscar.write_file(\n        poscar_path, significant_figures=self.poscar_significant_figures\n    )\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.make_potcar","title":"make_potcar","text":"<pre><code>make_potcar() -&gt; None\n</code></pre> <p>Create and write a POTCAR</p> Source code in <code>vasp_manager/vasp_input_creator.py</code> <pre><code>def make_potcar(self) -&gt; None:\n    \"\"\"\n    Create and write a POTCAR\n    \"\"\"\n    potcar_path = self.calc_dir / \"POTCAR\"\n    potcar_dir = Path(self.computing_config[\"potcar_dir\"])\n\n    el_names = [el.name for el in self.source_structure.composition]\n    self.logger.debug(\n        f\"{self.source_structure.composition.reduced_formula}, {el_names}\"\n    )\n    pot_singles = [\n        potcar_dir / self.potcar_dict[el_name] / \"POTCAR\" for el_name in el_names\n    ]\n    for pot_single in pot_singles:\n        if not pot_single.exists():\n            msg = f\"Unable to create POTCAR\\n\\tPOTCAR not found at path {pot_single}\"\n            raise Exception(msg)\n\n    potcar = pcat(pot_singles)\n    with open(potcar_path, \"w+\") as fw:\n        fw.write(potcar)\n</code></pre>"},{"location":"reference/vasp_manager/vasp_input_creator.html#vasp_manager.vasp_input_creator.VaspInputCreator.make_vaspq","title":"make_vaspq","text":"<pre><code>make_vaspq() -&gt; None\n</code></pre> <p>Create and write vasp.q file</p> Source code in <code>vasp_manager/vasp_input_creator.py</code> <pre><code>def make_vaspq(self) -&gt; None:\n    \"\"\"\n    Create and write vasp.q file\n    \"\"\"\n    vaspq_path = self.calc_dir / \"vasp.q\"\n\n    # create pad string for job naming to differentiate in the queue\n    match self.mode:\n        case \"rlx-coarse\" | \"rlx\":\n            if self.mode == \"rlx\":\n                pad_string = \"r\"\n            elif self.mode == \"rlx-coarse\":\n                pad_string = \"rc\"\n            mode = \"rlx\"\n        case \"static\":\n            pad_string = \"s\"\n            mode = \"static\"\n        case \"bulkmod\":\n            pad_string = \"b\"\n            mode = \"bulkmod\"\n        case \"elastic\":\n            pad_string = \"e\"\n            mode = \"elastic\"\n        case _:\n            raise ValueError(\n                \"Calculation type {self.mode} not in supported calculation types\"\n                \"of VaspInputCreator\"\n            )\n\n    jobname = pad_string + self.name\n    # convert walltime into seconds for increase_walltime_by_factor\n    walltime_iso = time.fromisoformat(self.calc_config[\"walltime\"])\n    # walltime_duration is in seconds\n    walltime_duration = timedelta(\n        hours=walltime_iso.hour,\n        minutes=walltime_iso.minute,\n        seconds=walltime_iso.second,\n    )\n    walltime_duration *= self.increase_walltime_by_factor\n    # convert to HH:MM:SS\n    walltime = str(walltime_duration)\n    # cut walltime short by 1 minute so job metrics log properly\n    timeout_as_delta = timedelta(seconds=walltime_duration.seconds - 60)\n    if self.computer == \"quest\":\n        # quest uses mpirun which needs timeout in seconds\n        timeout = str(timeout_as_delta.seconds)\n    else:\n        # otherwise, convert it back to HH:MM:SS\n        timeout = str(timeout_as_delta)\n\n    computing_config = self.computing_config.copy()\n    ncore_per_node = self.n_procs_used // self.n_nodes\n    computing_config.update(\n        {\n            \"n_nodes\": self.n_nodes,\n            \"n_procs\": self.n_procs,\n            \"ncore_per_node\": ncore_per_node,\n            \"jobname\": jobname,\n            \"walltime\": walltime,\n            \"timeout\": timeout,\n        }\n    )\n\n    vaspq_settings_path = self.q_mapper[self.computer][mode]\n    vaspq_settings = yaml.load(\n        importlib_resources.files(\"vasp_manager\")\n        .joinpath(str(Path(\"static_files\") / vaspq_settings_path))\n        .read_text(),\n        Loader=yaml.SafeLoader,\n    )\n    override_vaspq_settings_path = self.config_dir / f\"{self.computer}.yml\"\n    if override_vaspq_settings_path.exists():\n        with open(override_vaspq_settings_path) as fr:\n            override_vaspq_settings = yaml.load(\n                fr,\n                Loader=yaml.SafeLoader,\n            )\n        vaspq_settings.update(override_vaspq_settings)\n    vaspq_tmp = (\n        importlib_resources.files(\"vasp_manager\")\n        .joinpath(str(Path(\"static_files\") / \"vasp.q\"))\n        .read_text()\n    )\n    vaspq_tmp = vaspq_tmp.format(**vaspq_settings)\n    vaspq = vaspq_tmp.format(**computing_config)\n    self.logger.debug(vaspq)\n    with open(vaspq_path, \"w+\") as fw:\n        fw.write(vaspq)\n    vaspq_path.chmod(vaspq_path.stat().st_mode | stat.S_IEXEC)\n</code></pre>"},{"location":"reference/vasp_manager/vasp_manager.html","title":"vasp_manager","text":""},{"location":"reference/vasp_manager/vasp_manager.html#vasp_manager.vasp_manager.ASCII_LOGO","title":"ASCII_LOGO  <code>module-attribute</code>","text":"<pre><code>ASCII_LOGO = format(version('vasp_manager'))\n</code></pre>"},{"location":"reference/vasp_manager/vasp_manager.html#vasp_manager.vasp_manager.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/vasp_manager/vasp_manager.html#vasp_manager.vasp_manager.VaspManager","title":"VaspManager","text":"<pre><code>VaspManager(\n    calculation_types: list[CalculationType],\n    material_dirs: Filepaths | WorkingDirectory,\n    to_rerun: bool = True,\n    to_submit: bool = True,\n    ignore_personal_errors: bool = True,\n    tail: int = 5,\n    use_multiprocessing: bool = False,\n    ncore: None | int = None,\n    calculation_manager_kwargs: dict | None = None,\n    max_reruns: int = 3,\n    magmom_per_atom_cutoff: float = 0.0,\n    sort_by: Callable[[str], str] = str,\n)\n</code></pre> <p>Handles set up and execution of each CalculationManager     (rlx-coarse, rlx, static, bulkmod, elastic)</p> <p>Parameters:</p> <ul> <li> <code>calculation_types</code>               (<code>list[CalculationType]</code>)           \u2013            <p>list of calculation types</p> </li> <li> <code>material_dirs</code>               (<code>Filepaths | WorkingDirectory</code>)           \u2013            <p>list of material directory paths or name of calculations directory</p> </li> <li> <code>to_rerun</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, rerun failed calculations</p> </li> <li> <code>to_submit</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, submit calculations</p> </li> <li> <code>ignore_personal_errors</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, ignore job submission errors if on personal computer</p> </li> <li> <code>tail</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>number of last lines from stdout.txt to log in debugging if job failed</p> </li> <li> <code>use_multiprocessing</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if True, use pool.map()</p> </li> <li> <code>ncore</code>               (<code>None | int</code>, default:                   <code>None</code> )           \u2013            <p>if ncore, use {ncore} processes for multiprocessing if None, defaults to minimum(number of materials, 4)</p> </li> <li> <code>calculation_manager_kwargs</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>contains subdictionaries for each calculation type. Each subdictorary can be filled with extra kwargs to pass to its associated CalculationManager during instantiation</p> </li> <li> <code>max_reruns</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>the maximum number of times a rlx-coarse or rlx calculation can run before refusing to continue Note: other modes don't make archives, so they are not affected by this</p> </li> <li> <code>magmom_per_atom_cutoff</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>calculations that result in magmom_per_atom less than this parameter will be automatically rerun without spin-polarization</p> </li> <li> <code>sort_by</code>               (<code>Callable[[str], str]</code>, default:                   <code>str</code> )           \u2013            <p>function to sort the keys of the result dictionary</p> </li> </ul> Source code in <code>vasp_manager/vasp_manager.py</code> <pre><code>def __init__(\n    self,\n    calculation_types: list[CalculationType],\n    material_dirs: Filepaths | WorkingDirectory,\n    to_rerun: bool = True,\n    to_submit: bool = True,\n    ignore_personal_errors: bool = True,\n    tail: int = 5,\n    use_multiprocessing: bool = False,\n    ncore: None | int = None,\n    calculation_manager_kwargs: dict | None = None,\n    max_reruns: int = 3,\n    magmom_per_atom_cutoff: float = 0.0,\n    sort_by: Callable[[str], str] = str,\n) -&gt; None:\n    \"\"\"\n    Args:\n        calculation_types: list of calculation types\n        material_dirs: list of material directory paths or name of\n            calculations directory\n        to_rerun: if True, rerun failed calculations\n        to_submit: if True, submit calculations\n        ignore_personal_errors: if True, ignore job submission errors if on\n            personal computer\n        tail: number of last lines from stdout.txt to log in debugging\n            if job failed\n        use_multiprocessing: if True, use pool.map()\n        ncore: if ncore, use {ncore} processes for multiprocessing\n            if None, defaults to minimum(number of materials, 4)\n        calculation_manager_kwargs: contains subdictionaries for each\n            calculation type. Each subdictorary can be filled with extra kwargs\n            to pass to its associated CalculationManager during instantiation\n        max_reruns: the maximum number of times a rlx-coarse or rlx\n            calculation can run before refusing to continue\n            Note: other modes don't make archives, so they are not affected\n            by this\n        magmom_per_atom_cutoff: calculations that result in\n            magmom_per_atom less than this parameter will be automatically\n            rerun without spin-polarization\n        sort_by: function to sort the keys of the result dictionary\n    \"\"\"\n    print(ASCII_LOGO)\n    self.sort_by = sort_by\n    self.calculation_types = calculation_types\n    self.material_dirs = material_dirs\n    self.to_rerun = to_rerun\n    self.to_submit = to_submit\n    self.ignore_personal_errors = ignore_personal_errors\n    self.tail = tail\n    self.use_multiprocessing = use_multiprocessing\n    self.ncore = ncore\n    self.calculation_manager_kwargs = (\n        calculation_manager_kwargs if calculation_manager_kwargs else {}\n    )\n    self.max_reruns = max_reruns\n    self.magmom_per_atom_cutoff = magmom_per_atom_cutoff\n\n    self.calculation_managers = self._get_all_calculation_managers()\n    # self.base_dir is set in material_dirs.setter\n    self.results_path = self.base_dir / \"results.json\"\n    self.results = None\n</code></pre>"},{"location":"reference/vasp_manager/vasp_manager.html#vasp_manager.vasp_manager.VaspManager.calculation_manager_kwargs","title":"calculation_manager_kwargs  <code>property</code> <code>writable</code>","text":"<pre><code>calculation_manager_kwargs: dict\n</code></pre>"},{"location":"reference/vasp_manager/vasp_manager.html#vasp_manager.vasp_manager.VaspManager.calculation_managers","title":"calculation_managers  <code>instance-attribute</code>","text":"<pre><code>calculation_managers = _get_all_calculation_managers()\n</code></pre>"},{"location":"reference/vasp_manager/vasp_manager.html#vasp_manager.vasp_manager.VaspManager.calculation_types","title":"calculation_types  <code>property</code> <code>writable</code>","text":"<pre><code>calculation_types: list[CalculationType]\n</code></pre>"},{"location":"reference/vasp_manager/vasp_manager.html#vasp_manager.vasp_manager.VaspManager.ignore_personal_errors","title":"ignore_personal_errors  <code>instance-attribute</code>","text":"<pre><code>ignore_personal_errors = ignore_personal_errors\n</code></pre>"},{"location":"reference/vasp_manager/vasp_manager.html#vasp_manager.vasp_manager.VaspManager.magmom_per_atom_cutoff","title":"magmom_per_atom_cutoff  <code>instance-attribute</code>","text":"<pre><code>magmom_per_atom_cutoff = magmom_per_atom_cutoff\n</code></pre>"},{"location":"reference/vasp_manager/vasp_manager.html#vasp_manager.vasp_manager.VaspManager.material_dirs","title":"material_dirs  <code>property</code> <code>writable</code>","text":"<pre><code>material_dirs: Filepaths\n</code></pre>"},{"location":"reference/vasp_manager/vasp_manager.html#vasp_manager.vasp_manager.VaspManager.material_names","title":"material_names  <code>cached</code> <code>property</code>","text":"<pre><code>material_names: list[str]\n</code></pre>"},{"location":"reference/vasp_manager/vasp_manager.html#vasp_manager.vasp_manager.VaspManager.max_reruns","title":"max_reruns  <code>instance-attribute</code>","text":"<pre><code>max_reruns = max_reruns\n</code></pre>"},{"location":"reference/vasp_manager/vasp_manager.html#vasp_manager.vasp_manager.VaspManager.ncore","title":"ncore  <code>property</code> <code>writable</code>","text":"<pre><code>ncore: int\n</code></pre>"},{"location":"reference/vasp_manager/vasp_manager.html#vasp_manager.vasp_manager.VaspManager.results","title":"results  <code>property</code> <code>writable</code>","text":"<pre><code>results: dict\n</code></pre>"},{"location":"reference/vasp_manager/vasp_manager.html#vasp_manager.vasp_manager.VaspManager.results_path","title":"results_path  <code>instance-attribute</code>","text":"<pre><code>results_path = base_dir / 'results.json'\n</code></pre>"},{"location":"reference/vasp_manager/vasp_manager.html#vasp_manager.vasp_manager.VaspManager.sort_by","title":"sort_by  <code>instance-attribute</code>","text":"<pre><code>sort_by = sort_by\n</code></pre>"},{"location":"reference/vasp_manager/vasp_manager.html#vasp_manager.vasp_manager.VaspManager.tail","title":"tail  <code>instance-attribute</code>","text":"<pre><code>tail = tail\n</code></pre>"},{"location":"reference/vasp_manager/vasp_manager.html#vasp_manager.vasp_manager.VaspManager.to_rerun","title":"to_rerun  <code>instance-attribute</code>","text":"<pre><code>to_rerun = to_rerun\n</code></pre>"},{"location":"reference/vasp_manager/vasp_manager.html#vasp_manager.vasp_manager.VaspManager.to_submit","title":"to_submit  <code>instance-attribute</code>","text":"<pre><code>to_submit = to_submit\n</code></pre>"},{"location":"reference/vasp_manager/vasp_manager.html#vasp_manager.vasp_manager.VaspManager.use_multiprocessing","title":"use_multiprocessing  <code>instance-attribute</code>","text":"<pre><code>use_multiprocessing = use_multiprocessing\n</code></pre>"},{"location":"reference/vasp_manager/vasp_manager.html#vasp_manager.vasp_manager.VaspManager.run_calculations","title":"run_calculations","text":"<pre><code>run_calculations() -&gt; dict\n</code></pre> <p>Runs vasp job workflow for all materials</p> Source code in <code>vasp_manager/vasp_manager.py</code> <pre><code>def run_calculations(self) -&gt; dict:\n    \"\"\"\n    Runs vasp job workflow for all materials\n    \"\"\"\n    results = self._manage_calculations_wrapper()\n    for material_name, material_result in results:\n        self.results[material_name].update(material_result)\n\n    json_str = json.dumps(self.results, indent=2, cls=NumpyEncoder)\n    logger.debug(json_str)\n    with open(self.results_path, \"w+\") as fw:\n        fw.write(json_str)\n    print(f\"Dumped to {self.results_path}\")\n    return self.results\n</code></pre>"},{"location":"reference/vasp_manager/vasp_manager.html#vasp_manager.vasp_manager.VaspManager.summary","title":"summary","text":"<pre><code>summary(\n    as_string: bool = True,\n    print_unfinished: bool = False,\n    print_stopped: bool = True,\n) -&gt; str | dict\n</code></pre> <p>Create a string summary of all calculations</p> <p>Parameters:</p> <ul> <li> <code>as_string</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, return string summary. Else, return dict summary</p> </li> <li> <code>print_unfinished</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if True, include a list of unfinished materials for each calculation type in the summary</p> </li> <li> <code>print_stopped</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, include a list of stopped materials for each calculation type in the summary</p> </li> </ul> Source code in <code>vasp_manager/vasp_manager.py</code> <pre><code>def summary(\n    self,\n    as_string: bool = True,\n    print_unfinished: bool = False,\n    print_stopped: bool = True,\n) -&gt; str | dict:\n    \"\"\"\n    Create a string summary of all calculations\n\n    Args:\n        as_string: if True, return string summary. Else, return dict summary\n        print_unfinished: if True, include a list of unfinished\n            materials for each calculation type in the summary\n        print_stopped: if True, include a list of stopped materials for\n            each calculation type in the summary\n    \"\"\"\n    if not self.results_path.exists():\n        raise ValueError(f\"Can't find results in {self.results_path}\")\n    with open(self.results_path) as fr:\n        results = json.load(fr)\n\n    summary_dict: dict[str, Any] = {}\n    summary_dict[\"n_total\"] = len(results)\n    for calc_type in self.calculation_types:\n        summary_dict[calc_type] = {}\n        summary_dict[calc_type][\"n_finished\"] = 0\n        summary_dict[calc_type][\"finished\"] = []\n        summary_dict[calc_type][\"unfinished\"] = []\n        summary_dict[calc_type][\"stopped\"] = []\n\n        for material, mat_results in results.items():\n            # need to account for case key doesn't yet exist\n            if calc_type not in mat_results:\n                summary_dict[calc_type][\"unfinished\"].append(material)\n            else:\n                is_done, is_stopped = self._check_calc_by_result(material, calc_type)\n                if is_done:\n                    summary_dict[calc_type][\"n_finished\"] += 1\n                    summary_dict[calc_type][\"finished\"].append(material)\n                else:\n                    if is_stopped:\n                        summary_dict[calc_type][\"stopped\"].append(material)\n                    summary_dict[calc_type][\"unfinished\"].append(material)\n\n    if as_string:\n        n_materials = summary_dict[\"n_total\"]\n        summary_str = \"\"\n        summary_str += f\"Total Materials = {n_materials}\\n\"\n        summary_str += \"-\" * 30 + \"\\n\"\n        for calc_type in self.calculation_types:\n            name = calc_type.upper()\n            n_finished = summary_dict[calc_type][\"n_finished\"]\n            summary_str += f\"{name: &lt;12}{n_finished}/{n_materials} completed\\n\"\n            if print_unfinished:\n                unfinished = summary_dict[calc_type][\"unfinished\"]\n                if len(unfinished) != 0:\n                    summary_str += (\n                        \" \" * 12 + f\"{n_materials - n_finished} not completed\\n\"\n                    )\n                    summary_str += f\"Unfinished {calc_type.upper()}: {unfinished}\\n\"\n            if print_stopped:\n                stopped = summary_dict[calc_type][\"stopped\"]\n                if len(stopped) != 0:\n                    summary_str += f\"\\tStopped {calc_type.upper()}: {stopped}\\n\"\n        return summary_str\n    else:\n        return summary_dict\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/bulkmod_analyzer.html","title":"bulkmod_analyzer","text":""},{"location":"reference/vasp_manager/analyzer/bulkmod_analyzer.html#vasp_manager.analyzer.bulkmod_analyzer.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/bulkmod_analyzer.html#vasp_manager.analyzer.bulkmod_analyzer.BulkmodAnalyzer","title":"BulkmodAnalyzer","text":"<pre><code>BulkmodAnalyzer(\n    calc_dir: WorkingDirectory, rounding_precision: int = 3\n)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>calc_dir</code>               (<code>WorkingDirectory</code>)           \u2013            <p>path to bulkmod calculation directory</p> </li> <li> <code>rounding_precision</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>precision to round calculated quantities</p> </li> </ul> Source code in <code>vasp_manager/analyzer/bulkmod_analyzer.py</code> <pre><code>def __init__(\n    self,\n    calc_dir: WorkingDirectory,\n    rounding_precision: int = 3,\n) -&gt; None:\n    \"\"\"\n    Args:\n        calc_dir: path to bulkmod calculation directory\n        rounding_precision: precision to round calculated quantities\n    \"\"\"\n    self.calc_dir = Path(calc_dir)\n    self.rounding_precision = rounding_precision\n    self._results: dict\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/bulkmod_analyzer.html#vasp_manager.analyzer.bulkmod_analyzer.BulkmodAnalyzer.calc_dir","title":"calc_dir  <code>property</code> <code>writable</code>","text":"<pre><code>calc_dir: Path\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/bulkmod_analyzer.html#vasp_manager.analyzer.bulkmod_analyzer.BulkmodAnalyzer.results","title":"results  <code>property</code>","text":"<pre><code>results: dict\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/bulkmod_analyzer.html#vasp_manager.analyzer.bulkmod_analyzer.BulkmodAnalyzer.rounding_precision","title":"rounding_precision  <code>property</code> <code>writable</code>","text":"<pre><code>rounding_precision: int\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/bulkmod_analyzer.html#vasp_manager.analyzer.bulkmod_analyzer.BulkmodAnalyzer.analyze_bulkmod","title":"analyze_bulkmod  <code>staticmethod</code>","text":"<pre><code>analyze_bulkmod(\n    calc_dir: Path, rounding_precision: int\n) -&gt; dict\n</code></pre> <p>Fit an EOS to calculate the bulk modulus from a finished bulkmod calculation</p> Source code in <code>vasp_manager/analyzer/bulkmod_analyzer.py</code> <pre><code>@staticmethod\ndef analyze_bulkmod(calc_dir: Path, rounding_precision: int) -&gt; dict:\n    \"\"\"\n    Fit an EOS to calculate the bulk modulus from a finished bulkmod calculation\n    \"\"\"\n    strain_dirs = [path for path in calc_dir.glob(\"strain*\") if path.is_dir()]\n    strain_dirs = sorted(strain_dirs, key=lambda d: int(d.name.split(\"_\")[-1]))\n    volumes = []\n    final_energies = []\n    for i, strain_dir in enumerate(strain_dirs):\n        poscar_path = strain_dir / \"POSCAR\"\n        # search for vasprun.xml or vasprun.xml.gz\n        vasprun_glob = list(strain_dir.glob(\"vasprun.xml*\"))\n        if len(vasprun_glob) == 0:\n            raise Exception(f\"No vasprun.xml available at {strain_dir}\")\n        vasprun_path = vasprun_glob[0]\n        volume = Structure.from_file(poscar_path).volume\n        vasprun = Vasprun(\n            filename=vasprun_path,\n            parse_dos=False,\n            parse_eigen=False,\n            parse_potcar_file=False,\n        )\n        final_energy = vasprun.final_energy\n        volumes.append(volume)\n        final_energies.append(final_energy)\n    logger.debug(f\"Volumes:\\n\\t{volumes}\")\n    logger.debug(f\"Final Energies:\\n\\t{final_energies}\")\n    eos_analyzer = BirchMurnaghan(volumes, final_energies)\n    eos_analyzer.fit()\n    bulk_modulus = np.round(eos_analyzer.b0_GPa, rounding_precision)\n    logger.debug(f\"BULK MODULUS: {bulk_modulus}\")\n    b_dict = {\"B\": bulk_modulus}\n    return b_dict\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html","title":"elastic_analyzer","text":""},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer","title":"ElasticAnalyzer","text":"<pre><code>ElasticAnalyzer(\n    cij: NDArray,\n    structure: Structure,\n    rounding_precision: int = 3,\n)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>cij</code>               (<code>NDArray</code>)           \u2013            <p>stiffness tensor in Voigt notation in units of GPa</p> </li> <li> <code>structure</code>               (<code>Structure</code>)           \u2013            <p>the associated pymatgen structure</p> </li> <li> <code>rounding_precision</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>precision to round calculated quantities</p> </li> </ul> Note <p>Be careful with cij! VASP does not output stiffness tensors in typical Voigt notation. See change_elastic_constants_from_vasp method.</p> Source code in <code>vasp_manager/analyzer/elastic_analyzer.py</code> <pre><code>def __init__(\n    self,\n    cij: NDArray,\n    structure: Structure,\n    rounding_precision: int = 3,\n) -&gt; None:\n    \"\"\"\n    Args:\n        cij: stiffness tensor in Voigt notation in units of GPa\n        structure: the associated pymatgen structure\n        rounding_precision: precision to round calculated quantities\n\n    Note:\n        Be careful with cij! VASP does not output stiffness tensors in\n        typical Voigt notation. See change_elastic_constants_from_vasp\n        method.\n    \"\"\"\n    self.cij = cij\n    self.structure = structure\n    self.rounding_precision = rounding_precision\n    self._results: dict\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.b_reuss","title":"b_reuss  <code>cached</code> <code>property</code>","text":"<pre><code>b_reuss: Floating\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.b_voigt","title":"b_voigt  <code>cached</code> <code>property</code>","text":"<pre><code>b_voigt: Floating\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.b_vrh","title":"b_vrh  <code>cached</code> <code>property</code>","text":"<pre><code>b_vrh: Floating\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.cij","title":"cij  <code>property</code> <code>writable</code>","text":"<pre><code>cij: NDArray\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.density","title":"density  <code>property</code>","text":"<pre><code>density: float\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.elastically_unstable","title":"elastically_unstable  <code>cached</code> <code>property</code>","text":"<pre><code>elastically_unstable: bool\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.g_reuss","title":"g_reuss  <code>cached</code> <code>property</code>","text":"<pre><code>g_reuss: Floating\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.g_voigt","title":"g_voigt  <code>cached</code> <code>property</code>","text":"<pre><code>g_voigt: Floating\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.g_vrh","title":"g_vrh  <code>cached</code> <code>property</code>","text":"<pre><code>g_vrh: Floating\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.results","title":"results  <code>property</code>","text":"<pre><code>results: dict\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.rounding_precision","title":"rounding_precision  <code>property</code> <code>writable</code>","text":"<pre><code>rounding_precision: int\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.sij","title":"sij  <code>cached</code> <code>property</code>","text":"<pre><code>sij: NDArray\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.structure","title":"structure  <code>property</code> <code>writable</code>","text":"<pre><code>structure: Structure\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.vl","title":"vl  <code>cached</code> <code>property</code>","text":"<pre><code>vl: Floating\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.vs","title":"vs  <code>cached</code> <code>property</code>","text":"<pre><code>vs: Floating\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.vt","title":"vt  <code>cached</code> <code>property</code>","text":"<pre><code>vt: Floating\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.change_elastic_constants_from_vasp","title":"change_elastic_constants_from_vasp  <code>staticmethod</code>","text":"<pre><code>change_elastic_constants_from_vasp(\n    vasp_elastic_tensor: NDArray,\n) -&gt; NDArray\n</code></pre> <p>Parameters:</p> <ul> <li> <code>vasp_elastic_tensor</code>               (<code>NDArray</code>)           \u2013            <p>elastic tensor from VASP OUTCAR</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>elastic_tensor</code> (              <code>NDArray</code> )          \u2013            <p>reordered to match Voigt notation</p> </li> </ul> Note <p>VASP ordering of elastic constants is not the same as those expected by my equations below</p> <p>We should expect from Voigt notation: 1: 11 or xx 2: 22 or yy 3: 33 or zz 4: 23 or yz 5: 13 or xz 6: 12 or xy but VASP differs as it presents 1, 2, 3, 6 (xy), 4 (yz), 5 (xz) This function performs swapping to match expectations</p> Source code in <code>vasp_manager/analyzer/elastic_analyzer.py</code> <pre><code>@staticmethod\ndef change_elastic_constants_from_vasp(vasp_elastic_tensor: NDArray) -&gt; NDArray:\n    \"\"\"\n    Args:\n        vasp_elastic_tensor: elastic tensor from VASP OUTCAR\n\n    Returns:\n        elastic_tensor: reordered to match Voigt notation\n\n    Note:\n        VASP ordering of elastic constants is not the same as those expected by\n        my equations below\n\n        We should expect from Voigt notation:\n        1: 11 or xx\n        2: 22 or yy\n        3: 33 or zz\n        4: 23 or yz\n        5: 13 or xz\n        6: 12 or xy\n        but VASP differs as it presents 1, 2, 3, 6 (xy), 4 (yz), 5 (xz)\n        This function performs swapping to match expectations\n    \"\"\"\n    elastic_tensor = np.asarray(vasp_elastic_tensor).copy()\n    for j in range(6):\n        elastic_tensor[3, j], elastic_tensor[4, j], elastic_tensor[5, j] = (\n            elastic_tensor[4, j],\n            elastic_tensor[5, j],\n            elastic_tensor[3, j],\n        )\n    for i in range(6):\n        elastic_tensor[i, 3], elastic_tensor[i, 4], elastic_tensor[i, 5] = (\n            elastic_tensor[i, 4],\n            elastic_tensor[i, 5],\n            elastic_tensor[i, 3],\n        )\n    return elastic_tensor\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.check_elastically_unstable","title":"check_elastically_unstable  <code>staticmethod</code>","text":"<pre><code>check_elastically_unstable(cij: NDArray) -&gt; bool\n</code></pre> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if compound is elastically unstable</p> </li> </ul> Source code in <code>vasp_manager/analyzer/elastic_analyzer.py</code> <pre><code>@staticmethod\ndef check_elastically_unstable(cij: NDArray) -&gt; bool:\n    \"\"\"\n    Returns:\n        True if compound is elastically unstable\n    \"\"\"\n    eigenvalues, eigenvectors = np.linalg.eig(cij)\n    born_critera_satisfied = np.all(eigenvalues &gt; 0)\n    elastically_unstable = not born_critera_satisfied\n    return elastically_unstable\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.from_calc_dir","title":"from_calc_dir  <code>classmethod</code>","text":"<pre><code>from_calc_dir(\n    calc_dir: WorkingDirectory, **kwargs\n) -&gt; ElasticAnalyzer\n</code></pre> <p>Method to construct ElasticAnalyzer from a calculation directory. The directory should contain a POSCAR and an OUTCAR with elastic constants</p> <p>Parameters:</p> <ul> <li> <code>calc_dir</code>               (<code>WorkingDirectory</code>)           \u2013            </li> </ul> <p>Returns:</p> <ul> <li> <code>ElasticAnalyzer</code>           \u2013            <p>Instance of ElasticAnalyzer</p> </li> </ul> Source code in <code>vasp_manager/analyzer/elastic_analyzer.py</code> <pre><code>@classmethod\ndef from_calc_dir(\n    cls,\n    calc_dir: WorkingDirectory,\n    **kwargs,\n) -&gt; ElasticAnalyzer:\n    \"\"\"\n    Method to construct ElasticAnalyzer from a calculation directory.\n    The directory should contain a POSCAR and an OUTCAR with elastic constants\n\n    Args:\n        calc_dir:\n\n    Returns:\n        Instance of ElasticAnalyzer\n    \"\"\"\n    calc_dir = Path(calc_dir)\n    if not calc_dir.exists():\n        raise ValueError(f\"Could not set calc_dir to {calc_dir} as it does not exist\")\n\n    structure = Structure.from_file(calc_dir / \"POSCAR\")\n    outcar_glob = list(calc_dir.glob(\"OUTCAR*\"))\n    if len(outcar_glob) == 0:\n        raise FileNotFoundError(f\"No OUTCAR available in {calc_dir}\")\n    outcar_filepath = outcar_glob[0]\n\n    elastic_filepath = calc_dir / \"elastic_constants.txt\"\n    if not elastic_filepath.exists():\n        # Scrapes OUTCAR for elastic constants and write to elastic_constants.txt\n        elastic_table = pgrep(\n            outcar_filepath,\n            str_to_grep=\"TOTAL ELASTIC MOD\",\n            stop_after_first_match=True,\n            after=8,\n            as_string=True,\n        )\n        assert isinstance(elastic_table, str)\n        with open(elastic_filepath, \"w+\") as fw:\n            fw.write(elastic_table)\n\n    # Read the elastic constants and construct the stiffness tensor\n    with open(elastic_filepath) as fr:\n        raw_elastic_data = fr.readlines()\n    try:\n        # Skip first 3 rows as they are just header\n        # Skip the first column as it contains xx, xy, etc\n        elastic_data = [line.strip().split()[1:] for line in raw_elastic_data[3:]]\n        # Divide by 10 to get GPa instead of kBar\n        elastic_tensor = np.array(elastic_data, dtype=float) / 10.0\n        # VASP only outputs the stiffness tensor to 4 places\n        elastic_tensor = np.round(elastic_tensor, 4)\n        elastic_tensor = ElasticAnalyzer.change_elastic_constants_from_vasp(\n            elastic_tensor\n        )\n    except Exception as e:\n        raise RuntimeError(\n            \"Could not construct elastic tensor from OUTCAR. Please verify the\"\n            \" OUTCAR contains a full elastic tensor.\\n\"\n            f\"{e}\"\n        )\n    return cls(cij=elastic_tensor, structure=structure, **kwargs)\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.get_B_Reuss","title":"get_B_Reuss  <code>staticmethod</code>","text":"<pre><code>get_B_Reuss(sij: NDArray) -&gt; float\n</code></pre> <p>Parameters:</p> <ul> <li> <code>sij</code>               (<code>NDArray</code>)           \u2013            <p>compliance tensor</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>B_Reuss</code> (              <code>float</code> )          \u2013            <p>Reuss bulk modulus</p> </li> </ul> Source code in <code>vasp_manager/analyzer/elastic_analyzer.py</code> <pre><code>@staticmethod\ndef get_B_Reuss(sij: NDArray) -&gt; float:\n    \"\"\"\n    Args:\n        sij: compliance tensor\n\n    Returns:\n        B_Reuss: Reuss bulk modulus\n    \"\"\"\n    B_Reuss = 1 / (\n        (sij[0, 0] + sij[1, 1] + sij[2, 2]) + 2 * (sij[0, 1] + sij[1, 2] + sij[2, 0])\n    )\n    return B_Reuss\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.get_B_Voigt","title":"get_B_Voigt  <code>staticmethod</code>","text":"<pre><code>get_B_Voigt(cij: NDArray) -&gt; float\n</code></pre> <p>Parameters:</p> <ul> <li> <code>cij</code>               (<code>NDArray</code>)           \u2013            <p>stiffness tensor</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>B_Voigt</code> (              <code>float</code> )          \u2013            <p>Voigt bulk modulus</p> </li> </ul> Source code in <code>vasp_manager/analyzer/elastic_analyzer.py</code> <pre><code>@staticmethod\ndef get_B_Voigt(cij: NDArray) -&gt; float:\n    \"\"\"\n    Args:\n        cij: stiffness tensor\n\n    Returns:\n        B_Voigt: Voigt bulk modulus\n    \"\"\"\n    B_Voigt = (\n        (cij[0, 0] + cij[1, 1] + cij[2, 2]) + 2 * (cij[0, 1] + cij[1, 2] + cij[2, 0])\n    ) / 9\n    return B_Voigt\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.get_G_Reuss","title":"get_G_Reuss  <code>staticmethod</code>","text":"<pre><code>get_G_Reuss(sij: NDArray) -&gt; float\n</code></pre> <p>Parameters:</p> <ul> <li> <code>sij</code>               (<code>NDArray</code>)           \u2013            <p>compliance tensor</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>G_Reuss</code> (              <code>float</code> )          \u2013            <p>Reuss shear modulus</p> </li> </ul> Source code in <code>vasp_manager/analyzer/elastic_analyzer.py</code> <pre><code>@staticmethod\ndef get_G_Reuss(sij: NDArray) -&gt; float:\n    \"\"\"\n    Args:\n        sij: compliance tensor\n\n    Returns:\n        G_Reuss: Reuss shear modulus\n    \"\"\"\n    G_Reuss = 15 / (\n        4 * (sij[0, 0] + sij[1, 1] + sij[2, 2])\n        - 4 * (sij[0, 1] + sij[1, 2] + sij[2, 0])\n        + 3 * (sij[3, 3] + sij[4, 4] + sij[5, 5])\n    )\n    return G_Reuss\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.get_G_Voigt","title":"get_G_Voigt  <code>staticmethod</code>","text":"<pre><code>get_G_Voigt(cij: NDArray) -&gt; float\n</code></pre> <p>Parameters:</p> <ul> <li> <code>cij</code>               (<code>NDArray</code>)           \u2013            <p>stiffness tensor</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>G_Voigt</code> (              <code>float</code> )          \u2013            <p>Voigt shear modulus</p> </li> </ul> Source code in <code>vasp_manager/analyzer/elastic_analyzer.py</code> <pre><code>@staticmethod\ndef get_G_Voigt(cij: NDArray) -&gt; float:\n    \"\"\"\n    Args:\n        cij: stiffness tensor\n\n    Returns:\n        G_Voigt: Voigt shear modulus\n    \"\"\"\n    G_Voigt = (\n        (cij[0, 0] + cij[1, 1] + cij[2, 2])\n        - (cij[0, 1] + cij[1, 2] + cij[2, 0])\n        + 3 * (cij[3, 3] + cij[4, 4] + cij[5, 5])\n    ) / 15\n    return G_Voigt\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.get_VRH_average","title":"get_VRH_average  <code>staticmethod</code>","text":"<pre><code>get_VRH_average(mod1: Floating, mod2: Floating) -&gt; Floating\n</code></pre> <p>Parameters:</p> <ul> <li> <code>mod1</code>               (<code>Floating</code>)           \u2013            <p>B or G Voigt</p> </li> <li> <code>mod2</code>               (<code>Floating</code>)           \u2013            <p>B or G Reuss</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Floating</code>           \u2013            <p>VRH_average</p> </li> </ul> Source code in <code>vasp_manager/analyzer/elastic_analyzer.py</code> <pre><code>@staticmethod\ndef get_VRH_average(mod1: Floating, mod2: Floating) -&gt; Floating:\n    \"\"\"\n    Args:\n        mod1: B or G Voigt\n        mod2: B or G Reuss\n\n    Returns:\n        VRH_average\n    \"\"\"\n    return (mod1 + mod2) / 2.0\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.get_compliance_tensor","title":"get_compliance_tensor  <code>staticmethod</code>","text":"<pre><code>get_compliance_tensor(cij: NDArray) -&gt; NDArray\n</code></pre> <p>Parameters:</p> <ul> <li> <code>cij</code>               (<code>NDArray</code>)           \u2013            <p>stiffness tensor</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>sij</code> (              <code>NDArray</code> )          \u2013            <p>compliance tensor</p> </li> </ul> Source code in <code>vasp_manager/analyzer/elastic_analyzer.py</code> <pre><code>@staticmethod\ndef get_compliance_tensor(cij: NDArray) -&gt; NDArray:\n    \"\"\"\n    Args:\n        cij: stiffness tensor\n\n    Returns:\n        sij: compliance tensor\n    \"\"\"\n    sij = np.linalg.inv(cij)\n    return sij\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.get_vl","title":"get_vl  <code>staticmethod</code>","text":"<pre><code>get_vl(\n    bulkmod: Floating, shearmod: Floating, density: Floating\n) -&gt; Floating\n</code></pre> <p>Returns:</p> <ul> <li> <code>vl</code> (              <code>Floating</code> )          \u2013            <p>longitudinal speed of sound</p> </li> </ul> Source code in <code>vasp_manager/analyzer/elastic_analyzer.py</code> <pre><code>@staticmethod\ndef get_vl(\n    bulkmod: Floating,\n    shearmod: Floating,\n    density: Floating,\n) -&gt; Floating:\n    \"\"\"\n    Returns:\n        vl: longitudinal speed of sound\n    \"\"\"\n    vl = np.sqrt((bulkmod + 4 / 3 * shearmod) / density)\n    return vl\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.get_vs","title":"get_vs  <code>staticmethod</code>","text":"<pre><code>get_vs(\n    bulkmod: Floating, shearmod: Floating, density: Floating\n) -&gt; Floating\n</code></pre> <p>Returns:</p> <ul> <li> <code>vs</code> (              <code>Floating</code> )          \u2013            <p>speed of sound</p> </li> </ul> Source code in <code>vasp_manager/analyzer/elastic_analyzer.py</code> <pre><code>@staticmethod\ndef get_vs(\n    bulkmod: Floating,\n    shearmod: Floating,\n    density: Floating,\n) -&gt; Floating:\n    \"\"\"\n    Returns:\n        vs: speed of sound\n    \"\"\"\n    vl = np.sqrt((bulkmod + 4 / 3 * shearmod) / density)\n    vt = np.sqrt(shearmod / density)\n    vs = (1 / 3 * (1 / vl**3 + 2 / vt**3)) ** (-1 / 3)\n    return vs\n</code></pre>"},{"location":"reference/vasp_manager/analyzer/elastic_analyzer.html#vasp_manager.analyzer.elastic_analyzer.ElasticAnalyzer.get_vt","title":"get_vt  <code>staticmethod</code>","text":"<pre><code>get_vt(shearmod: Floating, density: Floating) -&gt; Floating\n</code></pre> <p>Returns:</p> <ul> <li> <code>vl</code> (              <code>Floating</code> )          \u2013            <p>transverse speed of sound</p> </li> </ul> Source code in <code>vasp_manager/analyzer/elastic_analyzer.py</code> <pre><code>@staticmethod\ndef get_vt(\n    shearmod: Floating,\n    density: Floating,\n) -&gt; Floating:\n    \"\"\"\n    Returns:\n        vl: transverse speed of sound\n    \"\"\"\n    vt = np.sqrt(shearmod / density)\n    return vt\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/base.html","title":"base","text":""},{"location":"reference/vasp_manager/calculation_manager/base.html#vasp_manager.calculation_manager.base.BaseCalculationManager","title":"BaseCalculationManager","text":"<pre><code>BaseCalculationManager(\n    material_dir: WorkingDirectory,\n    to_rerun: bool,\n    to_submit: bool,\n    primitive: bool = True,\n    ignore_personal_errors: bool = True,\n    from_scratch: bool = False,\n)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Runs vasp job workflow for a single material</p> <p>Parameters:</p> <ul> <li> <code>material_dir</code>               (<code>WorkingDirectory</code>)           \u2013            <p>path to a directory for a single material ex. calculations/AlAs</p> </li> <li> <code>to_rerun</code>               (<code>bool</code>)           \u2013            <p>if True, rerun failed calculations</p> </li> <li> <code>to_submit</code>               (<code>bool</code>)           \u2013            <p>if True, submit calculations to job manager</p> </li> <li> <code>primitive</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, find primitive cell, else find conventional cell</p> </li> <li> <code>ignore_personal_errors</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, ignore job submission errors if on personal computer</p> </li> <li> <code>from_scratch</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if True, remove the calculation's directory and restart note: DANGEROUS</p> </li> </ul> Source code in <code>vasp_manager/calculation_manager/base.py</code> <pre><code>def __init__(\n    self,\n    material_dir: WorkingDirectory,\n    to_rerun: bool,\n    to_submit: bool,\n    primitive: bool = True,\n    ignore_personal_errors: bool = True,\n    from_scratch: bool = False,  # DANGEROUS, WILL DELETE PREVIOUS CALCULATION\n):\n    \"\"\"\n    Args:\n        material_dir: path to a directory for a single material\n            ex. calculations/AlAs\n        to_rerun: if True, rerun failed calculations\n        to_submit: if True, submit calculations to job manager\n        primitive: if True, find primitive cell, else find conventional cell\n        ignore_personal_errors: if True, ignore job submission errors\n            if on personal computer\n        from_scratch: if True, remove the calculation's directory and\n            restart\n            note: DANGEROUS\n    \"\"\"\n    self.material_dir = Path(material_dir)\n    self.to_rerun = to_rerun\n    self.to_submit = to_submit\n    self.primitive = primitive\n    self.job_manager = JobManager(\n        calc_dir=self.calc_dir,\n        manager_name=f\"{self.material_name} {self.mode.upper()}\",\n        ignore_personal_errors=ignore_personal_errors,\n    )\n\n    self.from_scratch = from_scratch\n    if from_scratch:\n        self._from_scratch()\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/base.html#vasp_manager.calculation_manager.base.BaseCalculationManager.calc_dir","title":"calc_dir  <code>cached</code> <code>property</code>","text":"<pre><code>calc_dir: Path\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/base.html#vasp_manager.calculation_manager.base.BaseCalculationManager.from_scratch","title":"from_scratch  <code>instance-attribute</code>","text":"<pre><code>from_scratch = from_scratch\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/base.html#vasp_manager.calculation_manager.base.BaseCalculationManager.is_done","title":"is_done  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>is_done: bool\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/base.html#vasp_manager.calculation_manager.base.BaseCalculationManager.job_complete","title":"job_complete  <code>property</code>","text":"<pre><code>job_complete: bool\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/base.html#vasp_manager.calculation_manager.base.BaseCalculationManager.job_exists","title":"job_exists  <code>property</code>","text":"<pre><code>job_exists: bool\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/base.html#vasp_manager.calculation_manager.base.BaseCalculationManager.job_manager","title":"job_manager  <code>instance-attribute</code>","text":"<pre><code>job_manager = JobManager(\n    calc_dir=calc_dir,\n    manager_name=f\"{material_name} {upper()}\",\n    ignore_personal_errors=ignore_personal_errors,\n)\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/base.html#vasp_manager.calculation_manager.base.BaseCalculationManager.material_dir","title":"material_dir  <code>instance-attribute</code>","text":"<pre><code>material_dir = Path(material_dir)\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/base.html#vasp_manager.calculation_manager.base.BaseCalculationManager.material_name","title":"material_name  <code>cached</code> <code>property</code>","text":"<pre><code>material_name: str\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/base.html#vasp_manager.calculation_manager.base.BaseCalculationManager.mode","title":"mode  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>mode: CalculationType\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/base.html#vasp_manager.calculation_manager.base.BaseCalculationManager.poscar_source_path","title":"poscar_source_path  <code>abstractmethod</code> <code>cached</code> <code>property</code>","text":"<pre><code>poscar_source_path: Path\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/base.html#vasp_manager.calculation_manager.base.BaseCalculationManager.primitive","title":"primitive  <code>instance-attribute</code>","text":"<pre><code>primitive = primitive\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/base.html#vasp_manager.calculation_manager.base.BaseCalculationManager.stopped","title":"stopped  <code>property</code>","text":"<pre><code>stopped: bool\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/base.html#vasp_manager.calculation_manager.base.BaseCalculationManager.to_rerun","title":"to_rerun  <code>instance-attribute</code>","text":"<pre><code>to_rerun = to_rerun\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/base.html#vasp_manager.calculation_manager.base.BaseCalculationManager.to_submit","title":"to_submit  <code>instance-attribute</code>","text":"<pre><code>to_submit = to_submit\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/base.html#vasp_manager.calculation_manager.base.BaseCalculationManager.vasp_input_creator","title":"vasp_input_creator  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>vasp_input_creator: VaspInputCreator\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/base.html#vasp_manager.calculation_manager.base.BaseCalculationManager.check_calc","title":"check_calc  <code>abstractmethod</code>","text":"<pre><code>check_calc() -&gt; bool\n</code></pre> Source code in <code>vasp_manager/calculation_manager/base.py</code> <pre><code>@abstractmethod\ndef check_calc(self) -&gt; bool:\n    pass\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/base.html#vasp_manager.calculation_manager.base.BaseCalculationManager.setup_calc","title":"setup_calc  <code>abstractmethod</code>","text":"<pre><code>setup_calc() -&gt; None\n</code></pre> Source code in <code>vasp_manager/calculation_manager/base.py</code> <pre><code>@abstractmethod\ndef setup_calc(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/base.html#vasp_manager.calculation_manager.base.BaseCalculationManager.stop","title":"stop","text":"<pre><code>stop() -&gt; None\n</code></pre> Source code in <code>vasp_manager/calculation_manager/base.py</code> <pre><code>def stop(self) -&gt; None:\n    with open(self.material_dir / \"STOP\", \"w+\"):\n        pass\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/base.html#vasp_manager.calculation_manager.base.BaseCalculationManager.submit_job","title":"submit_job","text":"<pre><code>submit_job() -&gt; bool\n</code></pre> Source code in <code>vasp_manager/calculation_manager/base.py</code> <pre><code>def submit_job(self) -&gt; bool:\n    return self.job_manager.submit_job()\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/bulkmod.html","title":"bulkmod","text":""},{"location":"reference/vasp_manager/calculation_manager/bulkmod.html#vasp_manager.calculation_manager.bulkmod.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/bulkmod.html#vasp_manager.calculation_manager.bulkmod.BulkmodCalculationManager","title":"BulkmodCalculationManager","text":"<pre><code>BulkmodCalculationManager(\n    material_dir: WorkingDirectory,\n    to_rerun: bool,\n    to_submit: bool,\n    primitive: bool = True,\n    ignore_personal_errors: bool = True,\n    from_scratch: bool = False,\n    from_relax: bool = True,\n    tail: int = 5,\n    strains: None | NDArray = None,\n)\n</code></pre> <p>               Bases: <code>BaseCalculationManager</code></p> <p>Runs bulk modulus job workflow for a single material</p> <p>Parameters:</p> <ul> <li> <code>material_dir</code>               (<code>WorkingDirectory</code>)           \u2013            <p>path to a directory for a single material</p> </li> <li> <code>to_rerun</code>               (<code>bool</code>)           \u2013            <p>if True, rerun failed calculations</p> </li> <li> <code>to_submit</code>               (<code>bool</code>)           \u2013            <p>if True, submit calculations to job manager</p> </li> <li> <code>primitive</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, find primitive cell, else find conventional cell</p> </li> <li> <code>ignore_personal_errors</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, ignore job submission errors if on personal computer</p> </li> <li> <code>from_scratch</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if True, remove the calculation's directory and restart</p> </li> <li> <code>from_relax</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, use CONTCAR from relax</p> </li> <li> <code>tail</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>number of last lines to log in debugging if job failed</p> </li> <li> <code>strains</code>               (<code>None | NDArray</code>, default:                   <code>None</code> )           \u2013            <p>fractional strain along each axis for each deformation if None, use np.linspace(start=0.925, stop=1.075, number=11)**(\u2153) len(strains) must be odd and strains must be centered around 0</p> </li> </ul> Source code in <code>vasp_manager/calculation_manager/bulkmod.py</code> <pre><code>def __init__(\n    self,\n    material_dir: WorkingDirectory,\n    to_rerun: bool,\n    to_submit: bool,\n    primitive: bool = True,\n    ignore_personal_errors: bool = True,\n    from_scratch: bool = False,\n    from_relax: bool = True,\n    tail: int = 5,\n    strains: None | NDArray = None,\n):\n    \"\"\"\n    Args:\n        material_dir: path to a directory for a single material\n        to_rerun: if True, rerun failed calculations\n        to_submit: if True, submit calculations to job manager\n        primitive: if True, find primitive cell, else find conventional cell\n        ignore_personal_errors: if True, ignore job submission errors\n            if on personal computer\n        from_scratch: if True, remove the calculation's directory and\n            restart\n        from_relax: if True, use CONTCAR from relax\n        tail: number of last lines to log in debugging if job failed\n        strains: fractional strain along each axis for each deformation\n            if None, use np.linspace(start=0.925, stop=1.075, number=11)**(1/3)\n            len(strains) must be odd and strains must be centered around 0\n    \"\"\"\n    self.from_relax = from_relax\n    self.strains = (\n        strains\n        if strains is not None\n        else np.power(np.linspace(0.925, 1.075, 11), 1 / 3)\n    )\n    self.tail = tail\n    super().__init__(\n        material_dir=material_dir,\n        to_rerun=to_rerun,\n        to_submit=to_submit,\n        primitive=primitive,\n        ignore_personal_errors=ignore_personal_errors,\n        from_scratch=from_scratch,\n    )\n    self._is_done: bool\n    self._results: None | str | dict\n    self.logger = LoggerAdapter(logging.getLogger(__name__), self.material_name)\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/bulkmod.html#vasp_manager.calculation_manager.bulkmod.BulkmodCalculationManager.from_relax","title":"from_relax  <code>instance-attribute</code>","text":"<pre><code>from_relax = from_relax\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/bulkmod.html#vasp_manager.calculation_manager.bulkmod.BulkmodCalculationManager.is_done","title":"is_done  <code>property</code>","text":"<pre><code>is_done: bool\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/bulkmod.html#vasp_manager.calculation_manager.bulkmod.BulkmodCalculationManager.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = LoggerAdapter(getLogger(__name__), material_name)\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/bulkmod.html#vasp_manager.calculation_manager.bulkmod.BulkmodCalculationManager.mode","title":"mode  <code>cached</code> <code>property</code>","text":"<pre><code>mode: CalculationType\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/bulkmod.html#vasp_manager.calculation_manager.bulkmod.BulkmodCalculationManager.poscar_source_path","title":"poscar_source_path  <code>cached</code> <code>property</code>","text":"<pre><code>poscar_source_path: Path\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/bulkmod.html#vasp_manager.calculation_manager.bulkmod.BulkmodCalculationManager.results","title":"results  <code>property</code>","text":"<pre><code>results: None | str | dict\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/bulkmod.html#vasp_manager.calculation_manager.bulkmod.BulkmodCalculationManager.strains","title":"strains  <code>property</code> <code>writable</code>","text":"<pre><code>strains: NDArray\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/bulkmod.html#vasp_manager.calculation_manager.bulkmod.BulkmodCalculationManager.tail","title":"tail  <code>instance-attribute</code>","text":"<pre><code>tail = tail\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/bulkmod.html#vasp_manager.calculation_manager.bulkmod.BulkmodCalculationManager.vasp_input_creator","title":"vasp_input_creator  <code>cached</code> <code>property</code>","text":"<pre><code>vasp_input_creator: VaspInputCreator\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/bulkmod.html#vasp_manager.calculation_manager.bulkmod.BulkmodCalculationManager.check_calc","title":"check_calc","text":"<pre><code>check_calc() -&gt; bool\n</code></pre> <p>Checks result of bulk modulus calculation</p> <p>Returns:</p> <ul> <li> <code>bulkmod_sucessful</code> (              <code>bool</code> )          \u2013            <p>if True, bulkmod calculation completed successfully</p> </li> </ul> Source code in <code>vasp_manager/calculation_manager/bulkmod.py</code> <pre><code>def check_calc(self) -&gt; bool:\n    \"\"\"\n    Checks result of bulk modulus calculation\n\n    Returns:\n        bulkmod_sucessful: if True, bulkmod calculation completed successfully\n    \"\"\"\n    if not self.job_complete:\n        self.logger.info(f\"{self.mode.upper()} job not finished\")\n        return False\n\n    for i, strain in enumerate(self.strains):\n        middle = int(len(self.strains) / 2)\n        strain_index = i - middle\n        strain_name = f\"strain_{strain_index}\"\n        strain_dir = self.calc_dir / strain_name\n        stdout_path = strain_dir / \"stdout.txt\"\n        stderr_path = strain_dir / \"stderr.txt\"\n        if not stdout_path.exists():\n            return False\n\n        vasp_errors = self._check_vasp_errors(\n            stdout_path=stdout_path, stderr_path=stderr_path, extra_errors=[\"NELM\"]\n        )\n        if len(vasp_errors) &gt; 0:\n            all_errors_addressed = self._address_vasp_errors(vasp_errors)\n            if all_errors_addressed:\n                if self.to_rerun:\n                    self.logger.info(f\"Rerunning {self.calc_dir}\")\n                    self._from_scratch()\n                    self.setup_calc()\n            else:\n                msg = (\n                    f\"{self.mode.upper()} Calculation: \"\n                    \"Couldn't address all VASP Errors\\n\"\n                    f\"\\tVASP Errors: {vasp_errors}\\n\"\n                    \"\\tRefusing to continue...\\n\"\n                )\n                self.logger.error(msg)\n                self.stop()\n            return False\n\n        grep_output = pgrep(stdout_path, \"1 F=\", stop_after_first_match=True)\n        if len(grep_output) == 0:\n            if self.to_rerun:\n                self.logger.info(f\"Rerunning {self.calc_dir}\")\n                # increase nodes as its likely the calculation failed\n                self._from_scratch()\n                self.setup_calc(increase_walltime_by_factor=2)\n            return False\n    return True\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/bulkmod.html#vasp_manager.calculation_manager.bulkmod.BulkmodCalculationManager.setup_calc","title":"setup_calc","text":"<pre><code>setup_calc(\n    increase_nodes_by_factor: int = 1,\n    increase_walltime_by_factor: int = 1,\n) -&gt; None\n</code></pre> <p>Sets up an EOS bulkmod calculation</p> Source code in <code>vasp_manager/calculation_manager/bulkmod.py</code> <pre><code>def setup_calc(\n    self,\n    increase_nodes_by_factor: int = 1,\n    increase_walltime_by_factor: int = 1,\n) -&gt; None:\n    \"\"\"\n    Sets up an EOS bulkmod calculation\n    \"\"\"\n    if not self.from_relax:\n        msg = (\n            \"Running bulk modulus calculation without previous relaxation\\n\"\n            \"\\tStarting structure must be fairly close to equilibrium volume!\"\n        )\n        self.logger.warning(msg)\n\n    self.vasp_input_creator.increase_nodes_by_factor = increase_nodes_by_factor\n    self.vasp_input_creator.increase_walltime_by_factor = increase_walltime_by_factor\n    self.vasp_input_creator.use_spin = self._check_use_spin()\n    self.vasp_input_creator.create()\n    self._make_bulkmod_strains()\n\n    if self.to_submit:\n        job_submitted = self.submit_job()\n        # job status returns True if sucessfully submitted, else False\n        if not job_submitted:\n            self.setup_calc()\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/elastic.html","title":"elastic","text":""},{"location":"reference/vasp_manager/calculation_manager/elastic.html#vasp_manager.calculation_manager.elastic.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/elastic.html#vasp_manager.calculation_manager.elastic.ElasticCalculationManager","title":"ElasticCalculationManager","text":"<pre><code>ElasticCalculationManager(\n    material_dir: WorkingDirectory,\n    to_rerun: bool,\n    to_submit: bool,\n    primitive: bool = False,\n    ignore_personal_errors: bool = True,\n    from_scratch: bool = False,\n    tail: int = 5,\n)\n</code></pre> <p>               Bases: <code>BaseCalculationManager</code></p> <p>Runs elastic deformation job workflow for a single material</p> <p>Parameters:</p> <ul> <li> <code>material_dir</code>               (<code>WorkingDirectory</code>)           \u2013            <p>path to a directory for a single material</p> </li> <li> <code>to_rerun</code>               (<code>bool</code>)           \u2013            <p>if True, rerun failed calculations</p> </li> <li> <code>to_submit</code>               (<code>bool</code>)           \u2013            <p>if True, submit calculations to job manager</p> </li> <li> <code>primitive</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if True, find primitive cell, else find conventional cell</p> </li> <li> <code>ignore_personal_errors</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, ignore job submission errors if on personal computer</p> </li> <li> <code>from_scratch</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if True, remove the calculation's directory and restart</p> </li> <li> <code>tail</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>number of last lines to log in debugging if job failed</p> </li> </ul> Note <p>primitive is set to False for elastic calculations as sometimes elongated or distorted cells lead to erroneous results</p> Source code in <code>vasp_manager/calculation_manager/elastic.py</code> <pre><code>def __init__(\n    self,\n    material_dir: WorkingDirectory,\n    to_rerun: bool,\n    to_submit: bool,\n    primitive: bool = False,\n    ignore_personal_errors: bool = True,\n    from_scratch: bool = False,\n    tail: int = 5,\n):\n    \"\"\"\n    Args:\n        material_dir: path to a directory for a single material\n        to_rerun: if True, rerun failed calculations\n        to_submit: if True, submit calculations to job manager\n        primitive: if True, find primitive cell, else find conventional cell\n        ignore_personal_errors: if True, ignore job submission errors\n            if on personal computer\n        from_scratch: if True, remove the calculation's directory and\n            restart\n        tail: number of last lines to log in debugging if job failed\n\n    Note:\n        primitive is set to False for elastic calculations as sometimes\n        elongated or distorted cells lead to erroneous results\n    \"\"\"\n    self.tail = tail\n    super().__init__(\n        material_dir=material_dir,\n        to_rerun=to_rerun,\n        to_submit=to_submit,\n        primitive=primitive,\n        ignore_personal_errors=ignore_personal_errors,\n        from_scratch=from_scratch,\n    )\n    self._is_done: bool\n    self._results: None | str | dict\n    self.logger = LoggerAdapter(logging.getLogger(__name__), self.material_name)\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/elastic.html#vasp_manager.calculation_manager.elastic.ElasticCalculationManager.is_done","title":"is_done  <code>property</code>","text":"<pre><code>is_done: bool\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/elastic.html#vasp_manager.calculation_manager.elastic.ElasticCalculationManager.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = LoggerAdapter(getLogger(__name__), material_name)\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/elastic.html#vasp_manager.calculation_manager.elastic.ElasticCalculationManager.mode","title":"mode  <code>cached</code> <code>property</code>","text":"<pre><code>mode: CalculationType\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/elastic.html#vasp_manager.calculation_manager.elastic.ElasticCalculationManager.poscar_source_path","title":"poscar_source_path  <code>cached</code> <code>property</code>","text":"<pre><code>poscar_source_path: Path\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/elastic.html#vasp_manager.calculation_manager.elastic.ElasticCalculationManager.results","title":"results  <code>property</code>","text":"<pre><code>results: None | str | dict\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/elastic.html#vasp_manager.calculation_manager.elastic.ElasticCalculationManager.tail","title":"tail  <code>instance-attribute</code>","text":"<pre><code>tail = tail\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/elastic.html#vasp_manager.calculation_manager.elastic.ElasticCalculationManager.vasp_input_creator","title":"vasp_input_creator  <code>cached</code> <code>property</code>","text":"<pre><code>vasp_input_creator: VaspInputCreator\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/elastic.html#vasp_manager.calculation_manager.elastic.ElasticCalculationManager.check_calc","title":"check_calc","text":"<pre><code>check_calc() -&gt; bool\n</code></pre> <p>Checks result of elastic calculation</p> <p>Returns:</p> <ul> <li> <code>elastic_successful</code> (              <code>bool</code> )          \u2013            <p>if True, elastic calculation completed successfully</p> </li> </ul> Source code in <code>vasp_manager/calculation_manager/elastic.py</code> <pre><code>def check_calc(self) -&gt; bool:\n    \"\"\"\n    Checks result of elastic calculation\n\n    Returns:\n        elastic_successful: if True, elastic calculation completed\n            successfully\n    \"\"\"\n    if not self.job_complete:\n        self.logger.info(f\"{self.mode.upper()} job not finished\")\n        return False\n\n    stdout_path = self.calc_dir / \"stdout.txt\"\n    if not stdout_path.exists():\n        # shouldn't get here unless function was called with submit=False\n        self.logger.info(f\"{self.mode.upper()} Calculation: No stdout.txt available\")\n        if self.to_rerun:\n            self._from_scratch()\n            self.setup_calc()\n        return False\n\n    vasp_errors = self._check_vasp_errors(extra_errors=[\"NELM\"])\n    if len(vasp_errors) &gt; 0:\n        all_errors_addressed = self._address_vasp_errors(vasp_errors)\n        if all_errors_addressed:\n            if self.to_rerun:\n                self.logger.info(f\"Rerunning {self.calc_dir}\")\n                self._from_scratch()\n                self.setup_calc()\n        else:\n            msg = (\n                f\"{self.mode.upper()} Calculation: \"\n                \"Couldn't address all VASP Errors\\n\"\n                f\"\\tVASP Errors: {vasp_errors}\\n\"\n                \"\\tRefusing to continue...\\n\"\n            )\n            self.logger.error(msg)\n            self.stop()\n        return False\n\n    grep_output = pgrep(stdout_path, str_to_grep=\"Total\")\n    if len(grep_output) == 0:\n        if self.to_rerun:\n            self.logger.info(f\"Rerunning {self.calc_dir}\")\n            # calculation failed before end of first SCF cycle\n            self._from_scratch()\n            self.setup_calc()\n        return False\n\n    # last grep line looks something like 'Total: 108/108'\n    last_grep_line = grep_output[-1].replace(\"/\", \" \").strip().split()\n    finished_deformations = int(last_grep_line[-2])\n    total_deformations = int(last_grep_line[-1])\n    self.logger.debug(last_grep_line)\n    if not finished_deformations == total_deformations:\n        tail_output = ptail(stdout_path, n_tail=self.tail, as_string=True)\n        self.logger.info(tail_output)\n        self.logger.info(f\"{self.mode.upper()} Calculation: FAILED\")\n        if self.to_rerun:\n            self.logger.info(f\"Rerunning {self.calc_dir}\")\n            # increase walltime as its likely the calculation failed\n            self._from_scratch()\n            self.setup_calc(increase_walltime_by_factor=2)\n        return False\n\n    self.logger.info(f\"{self.mode.upper()} Calculation: Success\")\n    return True\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/elastic.html#vasp_manager.calculation_manager.elastic.ElasticCalculationManager.setup_calc","title":"setup_calc","text":"<pre><code>setup_calc(\n    increase_nodes_by_factor: int = 1,\n    increase_walltime_by_factor: int = 1,\n) -&gt; None\n</code></pre> <p>Runs elastic constants routine through VASP</p> <p>By default, requires relaxation (as the elastic constants routine needs     the cell to be nearly at equilibrium)</p> Source code in <code>vasp_manager/calculation_manager/elastic.py</code> <pre><code>def setup_calc(\n    self,\n    increase_nodes_by_factor: int = 1,\n    increase_walltime_by_factor: int = 1,\n) -&gt; None:\n    \"\"\"\n    Runs elastic constants routine through VASP\n\n    By default, requires relaxation (as the elastic constants routine needs\n        the cell to be nearly at equilibrium)\n    \"\"\"\n    self.vasp_input_creator.increase_nodes_by_factor = increase_nodes_by_factor\n    self.vasp_input_creator.increase_walltime_by_factor = increase_walltime_by_factor\n    self.vasp_input_creator.use_spin = self._check_use_spin()\n    self.vasp_input_creator.create()\n\n    if self.to_submit:\n        job_submitted = self.submit_job()\n        # job status returns True if sucessfully submitted, else False\n        if not job_submitted:\n            self.setup_calc()\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx.html","title":"rlx","text":""},{"location":"reference/vasp_manager/calculation_manager/rlx.html#vasp_manager.calculation_manager.rlx.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx.html#vasp_manager.calculation_manager.rlx.RlxCalculationManager","title":"RlxCalculationManager","text":"<pre><code>RlxCalculationManager(\n    material_dir: WorkingDirectory,\n    to_rerun: bool,\n    to_submit: bool,\n    primitive: bool = True,\n    ignore_personal_errors: bool = True,\n    from_scratch: bool = False,\n    from_coarse_relax: bool = True,\n    tail: int = 5,\n    max_reruns: int = 3,\n    magmom_per_atom_cutoff: float = 0.0,\n)\n</code></pre> <p>               Bases: <code>BaseCalculationManager</code></p> <p>Runs relaxation job workflow for a single material</p> <p>Parameters:</p> <ul> <li> <code>material_dir</code>               (<code>WorkingDirectory</code>)           \u2013            <p>path to a directory for a single material</p> </li> <li> <code>to_rerun</code>               (<code>bool</code>)           \u2013            <p>if True, rerun failed calculations</p> </li> <li> <code>to_submit</code>               (<code>bool</code>)           \u2013            <p>if True, submit calculations to job manager</p> </li> <li> <code>primitive</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, find primitive cell, else find conventional cell</p> </li> <li> <code>ignore_personal_errors</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, ignore job submission errors if on personal computer</p> </li> <li> <code>from_scratch</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if True, remove the calculation's directory and restart</p> </li> <li> <code>from_coarse_relax</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, use CONTCAR from coarse relax</p> </li> <li> <code>tail</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>number of last lines to log in debugging if job failed</p> </li> <li> <code>max_reruns</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>maximum number of times to rerun rlx before refusing to continue</p> </li> <li> <code>magmom_per_atom_cutoff</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>calculations that result in magmom_per_atom less than this parameter will be automatically rerun without spin-polarization</p> </li> </ul> Source code in <code>vasp_manager/calculation_manager/rlx.py</code> <pre><code>def __init__(\n    self,\n    material_dir: WorkingDirectory,\n    to_rerun: bool,\n    to_submit: bool,\n    primitive: bool = True,\n    ignore_personal_errors: bool = True,\n    from_scratch: bool = False,\n    from_coarse_relax: bool = True,\n    tail: int = 5,\n    max_reruns: int = 3,\n    magmom_per_atom_cutoff: float = 0.0,\n):\n    \"\"\"\n    Args:\n        material_dir: path to a directory for a single material\n        to_rerun: if True, rerun failed calculations\n        to_submit: if True, submit calculations to job manager\n        primitive: if True, find primitive cell, else find conventional cell\n        ignore_personal_errors: if True, ignore job submission errors\n            if on personal computer\n        from_scratch: if True, remove the calculation's directory and\n            restart\n        from_coarse_relax: if True, use CONTCAR from coarse relax\n        tail: number of last lines to log in debugging if job failed\n        max_reruns: maximum number of times to rerun rlx before refusing to\n            continue\n        magmom_per_atom_cutoff: calculations that result in\n            magmom_per_atom less than this parameter will be automatically\n            rerun without spin-polarization\n    \"\"\"\n    self.from_coarse_relax = from_coarse_relax\n    self.tail = tail\n    self.max_reruns = max_reruns\n    self.magmom_per_atom_cutoff = magmom_per_atom_cutoff\n    super().__init__(\n        material_dir=material_dir,\n        to_rerun=to_rerun,\n        to_submit=to_submit,\n        primitive=primitive,\n        ignore_personal_errors=ignore_personal_errors,\n        from_scratch=from_scratch,\n    )\n    self._is_done: bool\n    self._results: None | str | dict\n    self.logger = LoggerAdapter(logging.getLogger(__name__), self.material_name)\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx.html#vasp_manager.calculation_manager.rlx.RlxCalculationManager.from_coarse_relax","title":"from_coarse_relax  <code>instance-attribute</code>","text":"<pre><code>from_coarse_relax = from_coarse_relax\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx.html#vasp_manager.calculation_manager.rlx.RlxCalculationManager.is_done","title":"is_done  <code>property</code>","text":"<pre><code>is_done: bool\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx.html#vasp_manager.calculation_manager.rlx.RlxCalculationManager.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = LoggerAdapter(getLogger(__name__), material_name)\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx.html#vasp_manager.calculation_manager.rlx.RlxCalculationManager.magmom_per_atom_cutoff","title":"magmom_per_atom_cutoff  <code>instance-attribute</code>","text":"<pre><code>magmom_per_atom_cutoff = magmom_per_atom_cutoff\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx.html#vasp_manager.calculation_manager.rlx.RlxCalculationManager.max_reruns","title":"max_reruns  <code>instance-attribute</code>","text":"<pre><code>max_reruns = max_reruns\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx.html#vasp_manager.calculation_manager.rlx.RlxCalculationManager.mode","title":"mode  <code>cached</code> <code>property</code>","text":"<pre><code>mode: CalculationType\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx.html#vasp_manager.calculation_manager.rlx.RlxCalculationManager.poscar_source_path","title":"poscar_source_path  <code>cached</code> <code>property</code>","text":"<pre><code>poscar_source_path: Path\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx.html#vasp_manager.calculation_manager.rlx.RlxCalculationManager.results","title":"results  <code>property</code>","text":"<pre><code>results: None | str | dict\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx.html#vasp_manager.calculation_manager.rlx.RlxCalculationManager.tail","title":"tail  <code>instance-attribute</code>","text":"<pre><code>tail = tail\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx.html#vasp_manager.calculation_manager.rlx.RlxCalculationManager.vasp_input_creator","title":"vasp_input_creator  <code>cached</code> <code>property</code>","text":"<pre><code>vasp_input_creator: VaspInputCreator\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx.html#vasp_manager.calculation_manager.rlx.RlxCalculationManager.check_calc","title":"check_calc","text":"<pre><code>check_calc() -&gt; bool\n</code></pre> <p>Checks if calculation has finished and reached required accuracy</p> <p>Returns:</p> <ul> <li> <code>relaxation_successful</code> (              <code>bool</code> )          \u2013            <p>if True, relaxation completed successfully</p> </li> </ul> Source code in <code>vasp_manager/calculation_manager/rlx.py</code> <pre><code>def check_calc(self) -&gt; bool:\n    \"\"\"\n    Checks if calculation has finished and reached required accuracy\n\n    Returns:\n        relaxation_successful: if True, relaxation completed successfully\n    \"\"\"\n    if not self.job_complete:\n        self.logger.info(f\"{self.mode.upper()} not finished\")\n        return False\n\n    stdout_path = self.calc_dir / \"stdout.txt\"\n    if not stdout_path.exists():\n        # calculation never actually ran\n        # shouldn't get here unless function was called with submit=False\n        # or job was manually cancelled\n        self.logger.info(f\"{self.mode.upper()} Calculation: No stdout.txt available\")\n        if self.to_rerun:\n            self._cancel_previous_job()\n            self.setup_calc()\n        return False\n\n    vasp_errors = self._check_vasp_errors()\n    if len(vasp_errors) &gt; 0:\n        all_errors_addressed = self._address_vasp_errors(vasp_errors)\n        if all_errors_addressed:\n            if self.to_rerun:\n                self.logger.info(f\"Rerunning {self.calc_dir}\")\n                self.setup_calc(make_archive=True)\n        else:\n            msg = (\n                f\"{self.mode.upper()} Calculation: \"\n                \"Couldn't address all VASP Errors\\n\"\n                f\"\\tVASP Errors: {vasp_errors}\\n\"\n                \"\\tRefusing to continue...\\n\"\n            )\n            self.logger.error(msg)\n            self.stop()\n        return False\n\n    previous_magmom_per_atom = self._parse_magmom_per_atom()\n    if previous_magmom_per_atom is None:\n        use_spin = False\n    else:\n        use_spin = np.abs(previous_magmom_per_atom) &gt;= self.magmom_per_atom_cutoff\n\n    tail_output = ptail(stdout_path, n_tail=self.tail, as_string=True)\n    grep_output = pgrep(\n        stdout_path, \"reached required accuracy\", stop_after_first_match=True\n    )\n    if len(grep_output) == 0:\n        archive_dirs = list(self.calc_dir.glob(\"archive*\"))\n        if len(archive_dirs) &gt;= self.max_reruns - 1:\n            msg = (\n                \"Many archives exist, calculations may not be converging\\n\"\n                \"\\tRefusing to continue...\"\n            )\n            self.logger.error(msg)\n            return False\n\n        self.logger.warning(f\"{self.mode.upper()} FAILED\")\n        self.logger.debug(tail_output)\n        if self.to_rerun:\n            self.logger.info(f\"Rerunning {self.calc_dir}\")\n            # increase nodes as its likely the calculation failed\n            self.setup_calc(\n                increase_walltime_by_factor=2, make_archive=True, use_spin=use_spin\n            )\n        return False\n\n    # in the case that the calculation finishes but results in a spin value lower\n    # than the cutoff, rerun it without spin\n    if not use_spin and previous_magmom_per_atom is not None:\n        if self.to_rerun:\n            self.logger.info(f\"Rerunning {self.calc_dir}\")\n            self.setup_calc(make_archive=True, use_spin=False)\n        return False\n\n    self.logger.info(f\"{self.mode.upper()} Calculation: reached required accuracy\")\n    self.logger.debug(tail_output)\n    return True\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx.html#vasp_manager.calculation_manager.rlx.RlxCalculationManager.check_volume_difference","title":"check_volume_difference","text":"<pre><code>check_volume_difference() -&gt; bool\n</code></pre> <p>Checks relaxation runs for volume difference</p> <p>if abs(volume difference) is &gt;= 5%, reruns relaxation only checks for mode='rlx' as that's the structure for further calculation</p> <p>Returns:</p> <ul> <li> <code>volume_converged</code> (              <code>bool</code> )          \u2013            <p>if True, relaxation completed successfully</p> </li> </ul> Source code in <code>vasp_manager/calculation_manager/rlx.py</code> <pre><code>def check_volume_difference(self) -&gt; bool:\n    \"\"\"\n    Checks relaxation runs for volume difference\n\n    if abs(volume difference) is &gt;= 5%, reruns relaxation\n    only checks for mode='rlx' as that's the structure for further calculation\n\n    Returns:\n        volume_converged: if True, relaxation completed successfully\n    \"\"\"\n    original_poscar_path = self.material_dir / \"POSCAR\"\n    poscar_path = self.calc_dir / \"POSCAR\"\n    contcar_path = self.calc_dir / \"CONTCAR\"\n    try:\n        orig_structure, orig_spacegroup = get_pmg_structure_from_poscar(\n            original_poscar_path, return_spacegroup=True\n        )\n        p_structure, p_spacegroup = get_pmg_structure_from_poscar(\n            poscar_path, return_spacegroup=True\n        )\n        c_structure, c_spacegroup = get_pmg_structure_from_poscar(\n            contcar_path, return_spacegroup=True\n        )\n    except Exception as e:\n        self.logger.error(f\"RLX CONTCAR doesn't exist or is empty: {e}\")\n        return False\n\n    if orig_spacegroup == c_spacegroup:\n        self.logger.debug(\n            f\"Spacegroups match orig-{orig_spacegroup} == rlx-{c_spacegroup}\"\n        )\n    else:\n        self.logger.warning(\n            \"Warning: spacegroups do not match \"\n            + f\"orig-{orig_spacegroup} != rlx-{c_spacegroup}\"\n        )\n\n    volume_diff = (c_structure.volume - p_structure.volume) / p_structure.volume\n    if np.abs(volume_diff) &gt;= 0.05:\n        self.logger.warning(f\"NEED TO RE-RELAX: dV = {volume_diff:.4f}\")\n        volume_converged = False\n        previous_magmom_per_atom = self._parse_magmom_per_atom()\n        if previous_magmom_per_atom is None:\n            use_spin = False\n        else:\n            use_spin = np.abs(previous_magmom_per_atom) &gt;= self.magmom_per_atom_cutoff\n        if self.to_rerun:\n            self.setup_calc(make_archive=True, use_spin=use_spin)\n    else:\n        self.logger.info(\"RLX volume converged\")\n        self.logger.debug(f\"dV = {volume_diff:.4f}\")\n        volume_converged = True\n    orig_volume_diff = (\n        c_structure.volume - orig_structure.volume\n    ) / orig_structure.volume\n    self._results = {}\n    self._results[\"initial_spacegroup\"] = orig_spacegroup\n    self._results[\"relaxed_spacegroup\"] = c_spacegroup\n    self._results[\"total_dV\"] = np.round(orig_volume_diff, 4)\n    return volume_converged\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx.html#vasp_manager.calculation_manager.rlx.RlxCalculationManager.setup_calc","title":"setup_calc","text":"<pre><code>setup_calc(\n    increase_nodes_by_factor: int = 1,\n    increase_walltime_by_factor: int = 1,\n    make_archive: bool = False,\n    use_spin: bool = True,\n) -&gt; None\n</code></pre> <p>Sets up a fine relaxation</p> Source code in <code>vasp_manager/calculation_manager/rlx.py</code> <pre><code>def setup_calc(\n    self,\n    increase_nodes_by_factor: int = 1,\n    increase_walltime_by_factor: int = 1,\n    make_archive: bool = False,\n    use_spin: bool = True,\n) -&gt; None:\n    \"\"\"\n    Sets up a fine relaxation\n    \"\"\"\n    self.vasp_input_creator.increase_nodes_by_factor = increase_nodes_by_factor\n    self.vasp_input_creator.increase_walltime_by_factor = increase_walltime_by_factor\n    self.vasp_input_creator.use_spin = use_spin\n\n    if make_archive:\n        self.vasp_input_creator.make_archive_and_repopulate()\n    else:\n        self.vasp_input_creator.create()\n\n    if self.to_submit:\n        job_submitted = self.submit_job()\n        if not job_submitted:\n            self.setup_calc()\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx_coarse.html","title":"rlx_coarse","text":""},{"location":"reference/vasp_manager/calculation_manager/rlx_coarse.html#vasp_manager.calculation_manager.rlx_coarse.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx_coarse.html#vasp_manager.calculation_manager.rlx_coarse.RlxCoarseCalculationManager","title":"RlxCoarseCalculationManager","text":"<pre><code>RlxCoarseCalculationManager(\n    material_dir: WorkingDirectory,\n    to_rerun: bool,\n    to_submit: bool,\n    primitive: bool = True,\n    ignore_personal_errors: bool = True,\n    from_scratch: bool = False,\n    tail: int = 5,\n    max_reruns: int = 3,\n)\n</code></pre> <p>               Bases: <code>BaseCalculationManager</code></p> <p>Runs coarse relaxation job workflow for a single material</p> <p>Parameters:</p> <ul> <li> <code>material_dir</code>               (<code>WorkingDirectory</code>)           \u2013            <p>path to a directory for a single material</p> </li> <li> <code>to_rerun</code>               (<code>bool</code>)           \u2013            <p>if True, rerun failed calculations</p> </li> <li> <code>to_submit</code>               (<code>bool</code>)           \u2013            <p>if True, submit calculations to job manager</p> </li> <li> <code>primitive</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, find primitive cell, else find conventional cell</p> </li> <li> <code>ignore_personal_errors</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, ignore job submission errors if on personal computer</p> </li> <li> <code>from_scratch</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if True, remove the calculation's directory and restart</p> </li> <li> <code>tail</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>number of last lines to log in debugging if job failed</p> </li> <li> <code>max_reruns</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>maximum number of times to rerun rlx-coarse before continuing to rlx</p> </li> </ul> Source code in <code>vasp_manager/calculation_manager/rlx_coarse.py</code> <pre><code>def __init__(\n    self,\n    material_dir: WorkingDirectory,\n    to_rerun: bool,\n    to_submit: bool,\n    primitive: bool = True,\n    ignore_personal_errors: bool = True,\n    from_scratch: bool = False,\n    tail: int = 5,\n    max_reruns: int = 3,\n) -&gt; None:\n    \"\"\"\n    Args:\n        material_dir: path to a directory for a single material\n        to_rerun: if True, rerun failed calculations\n        to_submit: if True, submit calculations to job manager\n        primitive: if True, find primitive cell, else find conventional cell\n        ignore_personal_errors: if True, ignore job submission errors\n            if on personal computer\n        from_scratch: if True, remove the calculation's directory and\n            restart\n        tail: number of last lines to log in debugging if job failed\n        max_reruns: maximum number of times to rerun rlx-coarse before\n            continuing to rlx\n    \"\"\"\n    self.tail = tail\n    self.max_reruns = max_reruns\n    super().__init__(\n        material_dir=material_dir,\n        to_rerun=to_rerun,\n        to_submit=to_submit,\n        primitive=primitive,\n        ignore_personal_errors=ignore_personal_errors,\n        from_scratch=from_scratch,\n    )\n    self._is_done: bool\n    self._results: str\n    self.logger = LoggerAdapter(logging.getLogger(__name__), self.material_name)\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx_coarse.html#vasp_manager.calculation_manager.rlx_coarse.RlxCoarseCalculationManager.is_done","title":"is_done  <code>property</code>","text":"<pre><code>is_done: bool\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx_coarse.html#vasp_manager.calculation_manager.rlx_coarse.RlxCoarseCalculationManager.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = LoggerAdapter(getLogger(__name__), material_name)\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx_coarse.html#vasp_manager.calculation_manager.rlx_coarse.RlxCoarseCalculationManager.max_reruns","title":"max_reruns  <code>instance-attribute</code>","text":"<pre><code>max_reruns = max_reruns\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx_coarse.html#vasp_manager.calculation_manager.rlx_coarse.RlxCoarseCalculationManager.mode","title":"mode  <code>cached</code> <code>property</code>","text":"<pre><code>mode: CalculationType\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx_coarse.html#vasp_manager.calculation_manager.rlx_coarse.RlxCoarseCalculationManager.poscar_source_path","title":"poscar_source_path  <code>cached</code> <code>property</code>","text":"<pre><code>poscar_source_path: Path\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx_coarse.html#vasp_manager.calculation_manager.rlx_coarse.RlxCoarseCalculationManager.results","title":"results  <code>property</code>","text":"<pre><code>results: str\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx_coarse.html#vasp_manager.calculation_manager.rlx_coarse.RlxCoarseCalculationManager.tail","title":"tail  <code>instance-attribute</code>","text":"<pre><code>tail = tail\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx_coarse.html#vasp_manager.calculation_manager.rlx_coarse.RlxCoarseCalculationManager.vasp_input_creator","title":"vasp_input_creator  <code>cached</code> <code>property</code>","text":"<pre><code>vasp_input_creator: VaspInputCreator\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx_coarse.html#vasp_manager.calculation_manager.rlx_coarse.RlxCoarseCalculationManager.check_calc","title":"check_calc","text":"<pre><code>check_calc() -&gt; bool\n</code></pre> <p>Checks if calculation has finished and reached required accuracy</p> <p>Returns:</p> <ul> <li> <code>relaxation_successful</code> (              <code>bool</code> )          \u2013            <p>if True, relaxation completed successfully</p> </li> </ul> Source code in <code>vasp_manager/calculation_manager/rlx_coarse.py</code> <pre><code>def check_calc(self) -&gt; bool:\n    \"\"\"\n    Checks if calculation has finished and reached required accuracy\n\n    Returns:\n        relaxation_successful (bool): if True, relaxation completed successfully\n    \"\"\"\n    if not self.job_complete:\n        self.logger.info(f\"{self.mode.upper()} not finished\")\n        return False\n\n    stdout_path = self.calc_dir / \"stdout.txt\"\n    if not stdout_path.exists():\n        # calculation never actually ran\n        # shouldn't get here unless function was called with submit=False\n        # or job was manually cancelled\n        self.logger.info(f\"{self.mode.upper()} Calculation: No stdout.txt available\")\n        if self.to_rerun:\n            self._cancel_previous_job()\n            self.setup_calc()\n        return False\n\n    vasp_errors = self._check_vasp_errors()\n    if len(vasp_errors) &gt; 0:\n        all_errors_addressed = self._address_vasp_errors(vasp_errors)\n        if all_errors_addressed:\n            if self.to_rerun:\n                self.logger.info(f\"Rerunning {self.calc_dir}\")\n                self.setup_calc(make_archive=True)\n        else:\n            msg = (\n                f\"{self.mode.upper()} Calculation: \"\n                \"Couldn't address all VASP Errors\\n\"\n                f\"\\tVASP Errors: {vasp_errors}\\n\"\n                \"\\tRefusing to continue...\\n\"\n            )\n            self.logger.error(msg)\n            self.stop()\n        return False\n\n    tail_output = ptail(stdout_path, n_tail=self.tail, as_string=True)\n    grep_output = pgrep(\n        stdout_path, \"reached required accuracy\", stop_after_first_match=True\n    )\n    if len(grep_output) == 0:\n        archive_dirs = list(self.calc_dir.glob(\"archive*\"))\n        if len(archive_dirs) &gt;= self.max_reruns - 1:\n            self.logger.warning(\n                \"Many archives exist, continuing to force based relaxation...\"\n            )\n            return True\n\n        self.logger.warning(f\"{self.mode.upper()} FAILED\")\n        self.logger.debug(tail_output)\n        if self.to_rerun:\n            self.logger.info(f\"Rerunning {self.calc_dir}\")\n            # increase nodes as its likely the calculation failed\n            self.setup_calc(increase_walltime_by_factor=2, make_archive=True)\n        return False\n\n    self.logger.info(f\"{self.mode.upper()} Calculation: reached required accuracy\")\n    self.logger.debug(tail_output)\n    return True\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/rlx_coarse.html#vasp_manager.calculation_manager.rlx_coarse.RlxCoarseCalculationManager.setup_calc","title":"setup_calc","text":"<pre><code>setup_calc(\n    increase_nodes_by_factor: int = 1,\n    increase_walltime_by_factor: int = 1,\n    make_archive: bool = False,\n) -&gt; None\n</code></pre> <p>Sets up a coarse relaxation</p> Source code in <code>vasp_manager/calculation_manager/rlx_coarse.py</code> <pre><code>def setup_calc(\n    self,\n    increase_nodes_by_factor: int = 1,\n    increase_walltime_by_factor: int = 1,\n    make_archive: bool = False,\n) -&gt; None:\n    \"\"\"\n    Sets up a coarse relaxation\n    \"\"\"\n    self.vasp_input_creator.increase_nodes_by_factor = increase_nodes_by_factor\n    self.vasp_input_creator.increase_walltime_by_factor = increase_walltime_by_factor\n\n    if make_archive:\n        self.vasp_input_creator.make_archive_and_repopulate()\n    else:\n        self.vasp_input_creator.create()\n\n    if self.to_submit:\n        job_submitted = self.submit_job()\n        # job status returns True if sucessfully submitted, else False\n        if not job_submitted:\n            # if job didn't submit, try rerunning setup\n            self.setup_calc()\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/static.html","title":"static","text":""},{"location":"reference/vasp_manager/calculation_manager/static.html#vasp_manager.calculation_manager.static.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/static.html#vasp_manager.calculation_manager.static.StaticCalculationManager","title":"StaticCalculationManager","text":"<pre><code>StaticCalculationManager(\n    material_dir: WorkingDirectory,\n    to_rerun: bool,\n    to_submit: bool,\n    primitive: bool = True,\n    ignore_personal_errors: bool = True,\n    from_scratch: bool = False,\n    from_relax: bool = True,\n    tail: int = 5,\n)\n</code></pre> <p>               Bases: <code>BaseCalculationManager</code></p> <p>Runs static job workflow for a single material</p> <p>Parameters:</p> <ul> <li> <code>material_dir</code>               (<code>WorkingDirectory</code>)           \u2013            <p>path to a directory for a single material</p> </li> <li> <code>to_rerun</code>               (<code>bool</code>)           \u2013            <p>if True, rerun failed calculations</p> </li> <li> <code>to_submit</code>               (<code>bool</code>)           \u2013            <p>if True, submit calculations to job manager</p> </li> <li> <code>primitive</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, find primitive cell, else find conventional cell</p> </li> <li> <code>ignore_personal_errors</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, ignore job submission errors if on personal computer</p> </li> <li> <code>from_scratch</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if True, remove the calculation's directory and restart</p> </li> <li> <code>from_relax</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, use CONTCAR from relax</p> </li> <li> <code>tail</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>number of last lines to log in debugging if job failed</p> </li> </ul> Source code in <code>vasp_manager/calculation_manager/static.py</code> <pre><code>def __init__(\n    self,\n    material_dir: WorkingDirectory,\n    to_rerun: bool,\n    to_submit: bool,\n    primitive: bool = True,\n    ignore_personal_errors: bool = True,\n    from_scratch: bool = False,\n    from_relax: bool = True,\n    tail: int = 5,\n) -&gt; None:\n    \"\"\"\n    Args:\n        material_dir: path to a directory for a single material\n        to_rerun: if True, rerun failed calculations\n        to_submit: if True, submit calculations to job manager\n        primitive: if True, find primitive cell, else find conventional cell\n        ignore_personal_errors: if True, ignore job submission errors\n            if on personal computer\n        from_scratch: if True, remove the calculation's directory and\n            restart\n        from_relax: if True, use CONTCAR from relax\n        tail: number of last lines to log in debugging if job failed\n    \"\"\"\n    self.from_relax = from_relax\n    self.tail = tail\n    super().__init__(\n        material_dir=material_dir,\n        to_rerun=to_rerun,\n        to_submit=to_submit,\n        primitive=primitive,\n        ignore_personal_errors=ignore_personal_errors,\n        from_scratch=from_scratch,\n    )\n    self._is_done: bool\n    self._results: None | str | dict\n    self.logger = LoggerAdapter(logging.getLogger(__name__), self.material_name)\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/static.html#vasp_manager.calculation_manager.static.StaticCalculationManager.from_relax","title":"from_relax  <code>instance-attribute</code>","text":"<pre><code>from_relax = from_relax\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/static.html#vasp_manager.calculation_manager.static.StaticCalculationManager.is_done","title":"is_done  <code>property</code>","text":"<pre><code>is_done: bool\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/static.html#vasp_manager.calculation_manager.static.StaticCalculationManager.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = LoggerAdapter(getLogger(__name__), material_name)\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/static.html#vasp_manager.calculation_manager.static.StaticCalculationManager.mode","title":"mode  <code>cached</code> <code>property</code>","text":"<pre><code>mode: CalculationType\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/static.html#vasp_manager.calculation_manager.static.StaticCalculationManager.poscar_source_path","title":"poscar_source_path  <code>cached</code> <code>property</code>","text":"<pre><code>poscar_source_path: Path\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/static.html#vasp_manager.calculation_manager.static.StaticCalculationManager.results","title":"results  <code>property</code>","text":"<pre><code>results: None | str | dict\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/static.html#vasp_manager.calculation_manager.static.StaticCalculationManager.tail","title":"tail  <code>instance-attribute</code>","text":"<pre><code>tail = tail\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/static.html#vasp_manager.calculation_manager.static.StaticCalculationManager.vasp_input_creator","title":"vasp_input_creator  <code>cached</code> <code>property</code>","text":"<pre><code>vasp_input_creator: VaspInputCreator\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/static.html#vasp_manager.calculation_manager.static.StaticCalculationManager.check_calc","title":"check_calc","text":"<pre><code>check_calc() -&gt; bool\n</code></pre> <p>Checks result of static calculation</p> <p>Returns     static_successful: if True, static calculation completed successfully</p> Source code in <code>vasp_manager/calculation_manager/static.py</code> <pre><code>def check_calc(self) -&gt; bool:\n    \"\"\"\n    Checks result of static calculation\n\n    Returns\n        static_successful: if True, static calculation completed successfully\n    \"\"\"\n    if not self.job_complete:\n        self.logger.info(f\"{self.mode.upper()} not finished\")\n        return False\n\n    stdout_path = self.calc_dir / \"stdout.txt\"\n    if not stdout_path.exists():\n        # shouldn't get here unless function was called with submit=False\n        self.logger.info(f\"{self.mode.upper()} Calculation: No stdout.txt available\")\n        if self.to_rerun:\n            self._from_scratch()\n            self.setup_calc()\n        return False\n\n    vasp_errors = self._check_vasp_errors(extra_errors=[\"NELM\"])\n    if len(vasp_errors) &gt; 0:\n        all_errors_addressed = self._address_vasp_errors(vasp_errors)\n        if all_errors_addressed:\n            if self.to_rerun:\n                self.logger.info(f\"Rerunning {self.calc_dir}\")\n                self._from_scratch()\n                self.setup_calc()\n        else:\n            msg = (\n                f\"{self.mode.upper()} Calculation: \"\n                \"Couldn't address all VASP Errors\\n\"\n                f\"\\tVASP Errors: {vasp_errors}\\n\"\n                \"\\tRefusing to continue...\\n\"\n            )\n            self.logger.error(msg)\n            self.stop()\n        return False\n\n    tail_output = ptail(stdout_path, n_tail=self.tail, as_string=True)\n    grep_output = pgrep(stdout_path, \"1 F=\", stop_after_first_match=True)\n    if len(grep_output) == 0:\n        self.logger.warning(f\"{self.mode.upper()} FAILED\")\n        self.logger.debug(tail_output)\n        if self.to_rerun:\n            self.logger.info(f\"Rerunning {self.calc_dir}\")\n            self._from_scratch()\n            # increase nodes as its likely the calculation failed\n            self.setup_calc(increase_walltime_by_factor=2)\n        return False\n\n    self._results = {}\n    final_energy = float(grep_output[0].split()[2])\n    num_atoms = len(Structure.from_file(self.calc_dir / \"POSCAR\"))\n    magmom_per_atom = self._parse_magmom_per_atom()\n    self._results[\"final_energy\"] = final_energy\n    self._results[\"final_energy_pa\"] = final_energy / num_atoms\n    self._results[\"magmom_pa\"] = magmom_per_atom\n    self.logger.info(f\"{self.mode.upper()} Calculation: SCF converged\")\n    self.logger.debug(tail_output)\n    return True\n</code></pre>"},{"location":"reference/vasp_manager/calculation_manager/static.html#vasp_manager.calculation_manager.static.StaticCalculationManager.setup_calc","title":"setup_calc","text":"<pre><code>setup_calc(\n    increase_nodes_by_factor: int = 1,\n    increase_walltime_by_factor: int = 1,\n) -&gt; None\n</code></pre> <p>Runs a static SCF calculation through VASP</p> <p>By default, requires previous relaxation run</p> Source code in <code>vasp_manager/calculation_manager/static.py</code> <pre><code>def setup_calc(\n    self,\n    increase_nodes_by_factor: int = 1,\n    increase_walltime_by_factor: int = 1,\n) -&gt; None:\n    \"\"\"\n    Runs a static SCF calculation through VASP\n\n    By default, requires previous relaxation run\n    \"\"\"\n    self.vasp_input_creator.increase_nodes_by_factor = increase_nodes_by_factor\n    self.vasp_input_creator.increase_walltime_by_factor = increase_walltime_by_factor\n    self.vasp_input_creator.use_spin = self._check_use_spin()\n    self.vasp_input_creator.create()\n\n    if self.to_submit:\n        job_submitted = self.submit_job()\n        # job status returns True if sucessfully submitted, else False\n        if not job_submitted:\n            self.setup_calc()\n</code></pre>"},{"location":"user/about.html","title":"About vasp_manager","text":"<p>This package serves to automate <code>VASP</code> calculations. <code>VASP</code> input creation is automatic, and so is job submission, queue monitoring, calculation analysis, and storage of the results. Simply rerun the main script and any calculations that are ready for the next type of calculation will be created and submitted.</p>"},{"location":"user/about.html#vaspmanager","title":"VaspManager","text":"<p>The main class for handling all calculations is VaspManager, which takes in a list of calculation types and material paths. See the class documentation for more details. By default, results are exported to <code>calculations/results.json</code>.</p> <p>The bulk moduli analysis is carried out in the backend using the open-source <code>pymatgen</code> software to fit an EOS and elastic constant analysis using custom scripts.</p> <pre><code>graph TD\n  A[VaspManager] --&gt; B(Material 1) --&gt; F[(Results)]\n  A[VaspManager] --&gt; C(Material ...) --&gt; F[(Results)]\n  A[VaspManager] --&gt; D(Material ...) --&gt; F[(Results)]\n  A[VaspManager] --&gt; E(Material N) --&gt; F[(Results)]</code></pre>"},{"location":"user/calculation_modes.html","title":"Calculation Modes","text":"<p>We include calculation modes <code>\"rlx-coarse\"</code>, <code>\"rlx\"</code>, <code>\"static\"</code>, <code>\"bulkmod\"</code>, and <code>\"elastic\"</code>.  The desired modes to calculate are specified when initializing a <code>VaspManager</code> object.</p> <ul> <li><code>rlx-coarse</code>: lower precision energy-based relaxation</li> <li><code>rlx</code>: tighter relaxation (often force-based)</li> <li><code>static</code>: high accuracy static SCF calculation</li> <li><code>bulkmod</code>: bulk modulus calculation using an Equation of State (EOS) fit to an energy-volume curve</li> <li><code>elastic</code>: Determination of elastic constants using the strain/deformation method built into <code>VASP</code></li> </ul> <p>I generally recommend starting from <code>rlx-coarse</code>, although the functionality is there to start a <code>rlx</code> calculation from the initially provided POSCAR.</p> <p>Most users' workflows follow <code>rlx-coarse</code> \u2192 <code>rlx</code> \u2192 <code>static</code>. The modes <code>static</code>, <code>bulkmod</code>, and <code>elastic</code> can all be run independently of each other. For example, workflows might look like <code>rlx-coarse</code> \u2192 <code>rlx</code> \u2192 <code>static</code> \u2192 <code>bulkmod</code>, or <code>rlx</code> \u2192 <code>elastic</code>, or simply <code>static</code> or <code>bulkmod</code>.  The <code>elastic</code> mode requires at least <code>rlx</code> preceding it in order to guarantee converged lattice parameters and atomic positions.</p> <p>Example workflows are shown below:</p> BasicFullElastic <pre><code>graph LR\nrlx-coarse --&gt; rlx --&gt; static</code></pre> <pre><code>graph LR\nrlx-coarse --&gt; rlx --&gt; static &amp; bulkmod &amp; elastic</code></pre> <pre><code>graph LR\nrlx --&gt; elastic</code></pre>"},{"location":"user/extras.html","title":"Extras","text":"<ul> <li>To manually stop <code>VaspManager</code> from processing a material, place a <code>STOP</code> file in that material's directory: e.g. <code>calculations/NaCl/STOP</code>.</li> <li>The module logger is also made available for information and debugging and can be accessed through <code>logging.getLogger(\"vasp_manager\")</code>.</li> <li>The current implementation has only been tested on Linux and Mac OS.</li> <li>At this point, KPOINT generation is handled through the <code>KSPACING</code> tag in the   <code>INCAR</code>, but future versions will be able to specify KPPRA or a manual grid   instead. Spin-orbit coupling calculations are also not currently supported.</li> <li>On github, there's an <code>oqmd-settings</code> branch that roughly approximates the   relaxation and static settings of the OQMD. But, do note   that if you use this branch to try to compare with the OQMD, you should also   use the corresponding potpaw.52 pseudopotentials.</li> </ul>"},{"location":"user/installation.html","title":"Installation","text":""},{"location":"user/installation.html#install-python","title":"Install python","text":"<ol> <li>Install python version \\(\\geq\\) 3.10.<ul> <li>Preferably, you should use some sort of environment manager like   Miniconda   and create a new environment.</li> </ul> </li> </ol>"},{"location":"user/installation.html#install-vasp_manager","title":"Install vasp_manager","text":"<p>The simplest way is to use pip and install directly from PyPi. To install, run: <pre><code>pip install vasp-manager\n</code></pre></p> <p>Alternatively, start by cloning the github repository: <pre><code>git clone https://github.com/dgaines2/vasp_manager.git\n</code></pre></p> <p>And then cd into the <code>vasp_manager/</code> directory and install locally with pip:</p> LocalEditableEditable for Development <pre><code>pip install .\n</code></pre> <pre><code>pip install -e .\n</code></pre> <pre><code>pip install -e '.[dev]'\n</code></pre>"},{"location":"user/managers.html","title":"Managers","text":"<p>VaspManager handles the creation of a set of CalculationManagers for each material and specified calculation types. <pre><code>graph TD\nA[VaspManager] --&gt; C(Material 1) &amp; D(Material 2) &amp; E(Material ...)\nsubgraph identifier[\" \"]\ndirection LR\n  F(Material N) --&gt; G[RlxCoarseManager]\n  F --&gt; H[RlxManager]\n  F --&gt; I[StaticManager]\n  F --&gt; J[BulkmodManager]\n  F --&gt; K[ElasticManager]\nend\nA[VaspManager] --&gt; identifier[\" \"]</code></pre></p> <p>Each CalculationManager has its own logical flow in order to handle VASP input creation, job submission and monitoring, and result processing. <pre><code>graph TD\nA[CalculationManager] --&gt; B[VaspInputCreator]\nA --&gt; C[JobManager]\nA -.-&gt; D[Analzyer]</code></pre></p>"},{"location":"user/setting_up.html","title":"Setting Up","text":"<p>In order to use this package, you MUST</p> <ol> <li>Create a calculations folder where you'd like to run your calculations.    Each subfolder of <code>calculations/</code> should have a unique name and contain a    <code>POSCAR</code>. A sample method of creating the calculations folder from a <code>json</code>    with names and cifs is available in <code>run_vasp_calculations.py</code>, and an    example calculations folder is provided in <code>calculations/</code>.</li> <li>Configure <code>computing_config.json</code> and place it    in the <code>calculations/</code> directory.</li> <li>Make any desired modifications to    <code>calc_config.json</code> and place it in the    <code>calculations/</code> directory.</li> </ol> <p>When you're done, your calculation directory should look roughly like this: <pre><code>graph TD\n  A[calculations/] --&gt; B([calc_config.json]) &amp; C([computing_config.json])\n  A[calculations/] --&gt; D[Material 1] --&gt; E([POSCAR])\n  A[calculations/] --&gt; F[Material 2] --&gt; G([POSCAR])\n  A[calculations/] --&gt; H[Material ...] --&gt; I([POSCAR])</code></pre></p>"},{"location":"user/setting_up.html#computing-configuration","title":"Computing Configuration","text":"<p>The computing configuration is set up in <code>computing_config.json</code>.</p> <p>Here, you can configure settings for each supercomputer you would like to use. Be sure to check that <code>computer</code> at the top matches the supercomputer you're running jobs on.</p> <ul> <li>As of now, only Perlmutter and Bridges2 at NERSC and QUEST at Northwestern   University are supported. Any other SLURM based supercomputers can be easily   added, but modifications could be made for other queue management systems.</li> </ul>"},{"location":"user/setting_up.html#supported-tags","title":"Supported tags","text":"<ul> <li><code>user_id</code> (str)</li> <li><code>potcar_dir</code> (str)</li> <li><code>queuetype</code> (str)</li> <li><code>allocation</code> (str)</li> <li><code>constraint</code> (str)</li> <li><code>vasp_module</code> (str)</li> <li><code>ncore</code> (int)</li> <li><code>ncore_per_node</code> (int)</li> </ul> <p>Note</p> <ul> <li><code>potcar_dir</code> should be a global path to a folder containing VASP POTCARs.</li> <li><code>constraint</code> is only needed for Perlmutter (to specify cpu nodes).</li> <li><code>ncore</code> is NCORE in the VASP INCAR.</li> <li><code>ncore_per_node</code> should be the number of CPUs on each node.</li> <li>For <code>vasp_module</code>, a VASP 6 module is strongly recommended.</li> <li>The <code>personal</code> \"computer\" is only used for internal unit testing, not to   run any actual jobs.</li> </ul> <p>Warning</p> <p>Be sure that your settings of KPAR and NCORE are compatible with the computing architecture you're using!</p> <ul> <li>It's okay if <code>ncore * kpar != ncore_per_node</code>. All cores on the node will   still be requested, and some of them will be left empty for extra memory.   This can be useful for computing architectures with a weird number of   cores (e.g. 52 on Quest).</li> </ul> Example computing_config.json<pre><code>{\n  \"computer\": \"personal\",\n  \"personal\": {\n    \"user_id\": \"dwg4898\",\n    \"potcar_dir\": \"vasp_manager/tests/POTCARS\",\n    \"queuetype\": \"regular\",\n    \"allocation\": \"m1673\",\n    \"constraint\": \"cpu\",\n    \"vasp_module\": \"vasp/6.4.3-cpu\",\n    \"ncore\": 16,\n    \"ncore_per_node\": 128\n  },\n  \"quest\": {\n    \"user_id\": \"dwg4898\",\n    \"potcar_dir\": \"/projects/b1004/potpaw_PBE_OQMD\",\n    \"queuetype\": \"short\",\n    \"allocation\": \"p31151\",\n    \"vasp_module\": \"vasp/6.4.3-openmpi-intel-hdf5-cpu-only\",\n    \"ncore\": 12,\n    \"ncore_per_node\": 52\n  },\n  \"perlmutter\": {\n    \"user_id\": \"dwg4898\",\n    \"potcar_dir\": \"/global/homes/d/dwg4898/vasp_potentials/54/potpaw_pbe\",\n    \"queuetype\": \"regular\",\n    \"allocation\": \"m1673\",\n    \"constraint\": \"cpu\",\n    \"vasp_module\": \"vasp/6.4.3-cpu\",\n    \"ncore\": 16,\n    \"ncore_per_node\": 128\n  },\n  \"bridges2\": {\n    \"user_id\": \"daleg\",\n    \"potcar_dir\": \"/jet/home/daleg/vasp_potentials/potpaw_PBE_OQMD\",\n    \"queuetype\": \"RM\",\n    \"allocation\": \"dmr160027p\",\n    \"vasp_module\": \"\",\n    \"ncore\": 16,\n    \"ncore_per_node\": 128\n  }\n}\n</code></pre>"},{"location":"user/setting_up.html#calculation-configuration","title":"Calculation Configuration","text":"<p>Tip</p> <p>See more about <code>VASP</code> INCAR tags here</p> <p>The calculation configuration is set up in <code>calc_config.json</code>.</p> <p>For each desired calculation mode, set the INCAR tags in this json.</p> <ul> <li>Each mode has its own configuration settings with sensible defaults, but these can be easily customized by the user.</li> <li>See more about about spin polarization settings (<code>\"ispin\": \"auto\"</code>) here:   Spin Configuration</li> <li>See more about DFT+U settings (<code>\"hubbards\": \"wang\"</code>) here:   DFT+U Configuration</li> <li>Note: <code>VaspManager</code> uses 1 compute node per 32 atoms, so don't be surprised   if you job requests more than a single node.</li> </ul>"},{"location":"user/setting_up.html#supported-tags_1","title":"Supported tags:","text":"<ul> <li><code>prec</code> (<code>str</code>): [\"Normal\" | \"Accurate\"]</li> <li><code>ispin</code> (<code>str | int</code>): [\"auto\" | 1]</li> <li><code>hubbards</code> (<code>str | None</code>): [\"wang\" | null]</li> <li><code>kspacing</code> (<code>float</code>)</li> <li><code>symprec</code> (<code>float</code>)</li> <li><code>nsw</code> (<code>int</code>)</li> <li><code>ibrion</code> (<code>int</code>)</li> <li><code>isif</code> (<code>int</code>)</li> <li><code>lreal</code> (<code>bool</code>): [\".FALSE.\", \".TRUE.\"]</li> <li><code>potim</code> (<code>float</code>)</li> <li><code>ediffg</code> (<code>float</code>)</li> <li><code>iopt</code> (<code>int</code>)</li> <li><code>nelm</code> (<code>int</code>)</li> <li><code>encut</code> (<code>float</code>)</li> <li><code>ediff</code> (<code>float</code>)</li> <li><code>algo</code> (<code>str</code>): [\"Normal\" | \"Fast\" | \"VeryFast\"]</li> <li><code>ismear</code> (<code>int</code>)</li> <li><code>sigma</code> (<code>float</code>)</li> <li><code>amix</code> (<code>float</code>)</li> <li><code>bmix</code> (<code>float</code>)</li> <li><code>lwave</code> (<code>bool</code>): [\".FALSE.\", \".TRUE.\"]</li> <li><code>lcharge</code> (<code>bool</code>): [\".FALSE.\", \".TRUE.\"]</li> <li><code>lvot</code> (<code>bool</code>): [\".FALSE.\", \".TRUE.\"]</li> <li><code>kpar</code> (<code>int</code>)</li> <li><code>gga</code> (<code>str</code>)</li> <li><code>walltime</code> (<code>str</code>)</li> </ul> <p>Note</p> <ul> <li>In <code>json</code> files, the equivalent of python's <code>None</code> is <code>null</code>.</li> <li><code>VASP</code> (Fortran) expects <code>bool</code> data to be passed as <code>\".FALSE.\"</code> or   <code>\".TRUE.\"</code>.</li> <li>I prefer to write small floats (e.g. <code>\"1e-03\"</code>) as a string to prevent   them from being parsed as decimals (e.g. <code>0.001</code>).</li> <li><code>walltime</code> should be passed as <code>\"hh:mm:ss\"</code>. You should try to set this   such that your job hits NSW before it runs out of time.  If your job   fails or times out, an archive will be made and the calculation will be   resubmitted with a (2x) longer walltime.</li> <li>You can place another <code>calc_config.json</code> file in a specific material's calculation   directory (e.g. <code>NaCl/rlx</code>) to use custom settings for only that   material. You only need to include settings you want to change from the   main <code>calc_config.json</code>.</li> </ul> Example calc_config.json<pre><code>{\n  \"rlx-coarse\": {\n    \"prec\": \"ACC\",\n    \"ispin\": \"auto\",\n    \"hubbards\": \"wang\",\n    \"kspacing\": 0.2,\n    \"symprec\": \"1e-05\",\n    \"nsw\": 60,\n    \"ibrion\": 2,\n    \"isif\": 3,\n    \"lreal\": \".FALSE.\",\n    \"potim\": 0.1,\n    \"ediffg\": \"1e-04\",\n    \"iopt\": 0,\n    \"nelm\": 60,\n    \"encut\": 520,\n    \"ediff\": \"1e-05\",\n    \"algo\": \"Normal\",\n    \"ismear\": 0,\n    \"sigma\": 0.05,\n    \"kpar\": 4,\n    \"gga\": \"PE\",\n    \"walltime\": \"01:00:00\"\n  },\n  \"rlx\": {\n    \"prec\": \"ACC\",\n    \"ispin\": \"auto\",\n    \"hubbards\": \"wang\",\n    \"kspacing\": 0.15,\n    \"symprec\": \"1e-05\",\n    \"nsw\": 60,\n    \"ibrion\": 3,\n    \"isif\": 3,\n    \"lreal\": \".FALSE.\",\n    \"potim\": 0.1,\n    \"ediffg\": \"-1e-02\",\n    \"iopt\": 0,\n    \"nelm\": 60,\n    \"encut\": 520,\n    \"ediff\": \"1e-07\",\n    \"algo\": \"Normal\",\n    \"ismear\": 0,\n    \"sigma\": 0.05,\n    \"kpar\": 4,\n    \"gga\": \"PE\",\n    \"walltime\": \"01:00:00\"\n  },\n  \"static\": {\n    \"prec\": \"ACC\",\n    \"ispin\": \"auto\",\n    \"hubbards\": \"wang\",\n    \"kspacing\": 0.15,\n    \"symprec\": \"1e-05\",\n    \"nsw\": 0,\n    \"ibrion\": -1,\n    \"isif\": 3,\n    \"lreal\": \".FALSE.\",\n    \"potim\": 0,\n    \"ediffg\": \"-1e-02\",\n    \"iopt\": 0,\n    \"nelm\": 60,\n    \"encut\": 520,\n    \"ediff\": \"1e-07\",\n    \"algo\": \"Normal\",\n    \"ismear\": -5,\n    \"sigma\": 0.05,\n    \"kpar\": 4,\n    \"gga\": \"PE\",\n    \"walltime\": \"01:00:00\"\n  },\n  \"bulkmod\": {\n    \"prec\": \"ACC\",\n    \"ispin\": \"auto\",\n    \"hubbards\": \"wang\",\n    \"kspacing\": 0.15,\n    \"symprec\": \"1e-05\",\n    \"nsw\": 0,\n    \"ibrion\": -1,\n    \"isif\": 3,\n    \"lreal\": \".FALSE.\",\n    \"potim\": 0,\n    \"ediffg\": \"-1e-02\",\n    \"iopt\": 0,\n    \"nelm\": 60,\n    \"encut\": 520,\n    \"ediff\": \"1e-07\",\n    \"algo\": \"Normal\",\n    \"ismear\": -5,\n    \"sigma\": 0.05,\n    \"kpar\": 4,\n    \"gga\": \"PE\",\n    \"walltime\": \"02:00:00\"\n  },\n  \"elastic\": {\n    \"prec\": \"ACC\",\n    \"ispin\": \"auto\",\n    \"hubbards\": \"wang\",\n    \"kspacing\": 0.125,\n    \"write_kpoints\": true,\n    \"nfree\": 4,\n    \"symprec\": \"1e-05\",\n    \"nsw\": 60,\n    \"ibrion\": 6,\n    \"isif\": 3,\n    \"lreal\": \".FALSE.\",\n    \"potim\": 0.005,\n    \"ediffg\": \"-1e-02\",\n    \"iopt\": 0,\n    \"nelm\": 60,\n    \"encut\": 700,\n    \"ediff\": \"1e-07\",\n    \"algo\": \"Normal\",\n    \"ismear\": 0,\n    \"sigma\": 0.05,\n    \"kpar\": 4,\n    \"gga\": \"PE\",\n    \"walltime\": \"04:00:00\"\n  }\n}\n</code></pre>"},{"location":"user/user_config/hubbards.html","title":"DFT+U Configuration","text":"<p>When <code>\"hubbards\": \"wang\"</code> is set, we apply hubbard corrections to certain transition metals in the presence of oxygen.</p> <p>Warning</p> <p>Only PBE (<code>\"gga\": \"PE\"</code>) is supported with DFT+U in <code>vasp_manager</code></p> <p>We use <code>LDAUTYPE=2</code>: The simplified (rotationally invariant) approach to DFT+U, introduced by Dudarev et al <sup>1</sup> and U-J coefficients from Wang et al <sup>2</sup>. If no elements needing DFT+U are found in the structure, DFT+U is automatically not used.</p> <p>In the generated INCAR, this looks like: <pre><code># Example for FeO\n#= DFT+U =#\nLDAU = .TRUE.\nLDAUPRINT = 1\nLDAUU = 4.0 0.0\nLDAUJ = 0.0 0.0\nLDAUL = 2 -1\nLMAXMIX = 4\n</code></pre></p> <p>The DFT+U elements and their settings can be found in <code>hubbards.json</code>.</p> hubbards.json<pre><code>{\n  \"wang\": {\n    \"Co\": {\"L\": 2, \"U\": 3.3},\n    \"Cr\": {\"L\": 2, \"U\": 3.5},\n    \"Cu\": {\"L\": 2, \"U\": 4.0},\n    \"Fe\": {\"L\": 2, \"U\": 4.0},\n    \"Mn\": {\"L\": 2, \"U\": 3.8},\n    \"Ni\": {\"L\": 2, \"U\": 6.4},\n    \"Np\": {\"L\": 3, \"U\": 4.0},\n    \"Pa\": {\"L\": 3, \"U\": 4.0},\n    \"Pu\": {\"L\": 3, \"U\": 4.0},\n    \"Th\": {\"L\": 3, \"U\": 4.0},\n    \"U\": {\"L\": 3, \"U\": 4.0},\n    \"V\": {\"L\": 2, \"U\": 3.1}\n  }\n}\n</code></pre> <ol> <li> <p>https://doi.org/10.1103/PhysRevB.57.1505 \u21a9</p> </li> <li> <p>https://doi.org/10.1103/PhysRevB.73.195107 \u21a9</p> </li> </ol>"},{"location":"user/user_config/jobs.html","title":"Job Scripts","text":"<p>For each calculation, its job is handled by JobManager. This class can submit a job, store its jobid, and monitor its progress.</p> <p>The creation of the actual creation of the <code>vasp.q</code> SLURM submission script is handled by VaspInputCreator using settings from <code>calc_config.json</code> and <code>computing_config.json</code>.</p> <p>Implementation Details</p> <p>The <code>vasp.q</code> file is just a template string that needs to be passed 3 separate sections: vasp.q<pre><code>#!/bin/bash\n\n{sbatch_params}\n\n{preamble}\n\nstarttime=$(date +%s)\n\n{command}\n\nstoptime=$(date +%s)\ntottime=$(echo \"$stoptime - $starttime\" | bc -l)\necho \"total time (s): $tottime\"\nto_hours=$(echo \"scale=3; $tottime/3600\" | bc -l)\necho \"total time (hr): $to_hours\"\n</code></pre></p> <ol> <li><code>{sbatch_params}</code>: sbatch tags (e.g. <code>#SBATCH -N</code>)</li> <li><code>{preamble}</code>: environment or module settings (e.g. <code>export OMP_NUM_THREADS=1</code>)</li> <li><code>{command}</code>: the <code>mpi</code> or <code>srun</code> command to launch <code>VASP</code></li> </ol> <p>The actual commands for each supercomputer and job type are determined by <code>q_mapper.json</code> which lists the path of a yaml file that contains the <code>sbatch_params</code>, <code>preamble</code>, and <code>command</code> to use.</p> <p>You can modify the exact commands in the yaml file of your choice if needed. For reference, here's the yaml file for normal jobs on Perlmutter: vasp.yml<pre><code>sbatch_params: |-\n  #SBATCH -N {n_nodes}\n  #SBATCH -q {queuetype}\n  #SBATCH -J {jobname}\n  #SBATCH -A {allocation}\n  #SBATCH -t {walltime}\n  #SBATCH -C {constraint}\n  #SBATCH --mem=0\n\npreamble: |-\n  ulimit -s unlimited\n  export OMP_NUM_THREADS=1\n  module load {vasp_module}\n  mpitasks=$(echo \"$SLURM_JOB_NUM_NODES * {ncore_per_node}\" | bc)\n\ncommand: |-\n  srun -t {timeout} -u -n $mpitasks --cpu_bind=cores vasp_std &gt; stdout.txt 2&gt; stderr.txt\n</code></pre></p>"},{"location":"user/user_config/potentials.html","title":"Pseudopotential Configuration","text":"<p>We use VASP's recommended pseudopotentials for each element, specifically those from potpaw.54.</p> <p>This is stored in the <code>pot_dict.json</code> file.</p> Recommended Pseudopotentials pot_dict.json<pre><code>{\n    \"H\": \"H\",\n    \"He\": \"He\",\n    \"Li\": \"Li_sv\",\n    \"Be\": \"Be\",\n    \"B\": \"B\",\n    \"C\": \"C\",\n    \"N\": \"N\",\n    \"O\": \"O\",\n    \"F\": \"F\",\n    \"Ne\": \"Ne\",\n    \"Na\": \"Na_pv\",\n    \"Mg\": \"Mg\",\n    \"Al\": \"Al\",\n    \"Si\": \"Si\",\n    \"P\": \"P\",\n    \"S\": \"S\",\n    \"Cl\": \"Cl\",\n    \"Ar\": \"Ar\",\n    \"K\": \"K_sv\",\n    \"Ca\": \"Ca_sv\",\n    \"Sc\": \"Sc_sv\",\n    \"Ti\": \"Ti_sv\",\n    \"V\": \"V_sv\",\n    \"Cr\": \"Cr_pv\",\n    \"Mn\": \"Mn_pv\",\n    \"Fe\": \"Fe\",\n    \"Co\": \"Co\",\n    \"Ni\": \"Ni\",\n    \"Cu\": \"Cu\",\n    \"Zn\": \"Zn\",\n    \"Ga\": \"Ga_d\",\n    \"Ge\": \"Ge_d\",\n    \"As\": \"As\",\n    \"Se\": \"Se\",\n    \"Br\": \"Br\",\n    \"Kr\": \"Kr\",\n    \"Rb\": \"Rb_sv\",\n    \"Sr\": \"Sr_sv\",\n    \"Y\": \"Y_sv\",\n    \"Zr\": \"Zr_sv\",\n    \"Nb\": \"Nb_pv\",\n    \"Mo\": \"Mo_sv\",\n    \"Tc\": \"Tc_pv\",\n    \"Ru\": \"Ru_pv\",\n    \"Rh\": \"Rh_pv\",\n    \"Pd\": \"Pd\",\n    \"Ag\": \"Ag\",\n    \"Cd\": \"Cd\",\n    \"In\": \"In_d\",\n    \"Sn\": \"Sn_d\",\n    \"Sb\": \"Sb\",\n    \"Te\": \"Te\",\n    \"I\": \"I\",\n    \"Xe\": \"Xe\",\n    \"Cs\": \"Cs_sv\",\n    \"Ba\": \"Ba_sv\",\n    \"La\": \"La\",\n    \"Ce\": \"Ce\",\n    \"Pr\": \"Pr_3\",\n    \"Nd\": \"Nd_3\",\n    \"Pm\": \"Pm_3\",\n    \"Sm\": \"Sm_3\",\n    \"Eu\": \"Eu_2\",\n    \"Gd\": \"Gd_3\",\n    \"Tb\": \"Tb_3\",\n    \"Dy\": \"Dy_3\",\n    \"Ho\": \"Ho_3\",\n    \"Er\": \"Er_3\",\n    \"Tm\": \"Tm_3\",\n    \"Yb\": \"Yb_2\",\n    \"Lu\": \"Lu_3\",\n    \"Hf\": \"Hf_pv\",\n    \"Ta\": \"Ta_pv\",\n    \"W\": \"W_sv\",\n    \"Re\": \"Re\",\n    \"Os\": \"Os\",\n    \"Ir\": \"Ir\",\n    \"Pt\": \"Pt\",\n    \"Au\": \"Au\",\n    \"Hg\": \"Hg\",\n    \"Tl\": \"Tl_d\",\n    \"Pb\": \"Pb_d\",\n    \"Bi\": \"Bi_d\",\n    \"Po\": \"Po_d\",\n    \"At\": \"At\",\n    \"Rn\": \"Rn\",\n    \"Fr\": \"Fr_sv\",\n    \"Ra\": \"Ra_sv\",\n    \"Ac\": \"Ac\",\n    \"Th\": \"Th\",\n    \"Pa\": \"Pa\",\n    \"U\": \"U\",\n    \"Np\": \"Np\",\n    \"Pu\": \"Pu\",\n    \"Am\": \"Am\",\n    \"Cm\": \"Cm\"\n}\n</code></pre> <p>Warning</p> <p>This is technically an implementation detail, but <code>pot_dict.json</code> is a symbolic link to <code>pot_dict_54.json</code> in the same folder. We also provide <code>pot_dict_52.json</code> which contains the recommended pseudopotentials for potpaw.52.</p> <p>To change the symbolic link for potpaw.52, run the following commands in the <code>static_files</code> directory: <pre><code>rm pot_dict.json\nln -s pot_dict_52.json pot_dict.json\n</code></pre></p> <p>We also include a legacy version of pseudopotential choices for potpaw.52 to match the OQMD in <code>pot_dict_oqmd.json</code>.</p>"},{"location":"user/user_config/spin.html","title":"Spin Configuration","text":"<p>Spin polarization is controlled by the <code>\"ispin\"</code> tag in <code>calc_config.json</code>.</p> <p>To include spin polarization, set <code>\"ispin\": \"auto\"</code> in <code>calc_config.json</code>; otherwise set <code>\"ispin\": 1</code>. With this setting, all elements with valence d or f electrons will start with initial magnetic moments of 5 and 7 \\(\\mu_B\\), respectively.</p> <p>See more about <code>ISPIN</code> in VASP: ISPIN.</p> <p>The elements considered to be \\(d\\) and \\(f\\) block can be found in <code>d_f_block.json</code>.</p> d- and f-block elements d_f_block.json<pre><code>{\n  \"d_block\": [\n    \"Sc\",\n    \"Ti\",\n    \"V\",\n    \"Cr\",\n    \"Mn\",\n    \"Fe\",\n    \"Co\",\n    \"Ni\",\n    \"Cu\",\n    \"Zn\",\n    \"Y\",\n    \"Zr\",\n    \"Nb\",\n    \"Mo\",\n    \"Tc\",\n    \"Ru\",\n    \"Rh\",\n    \"Pd\",\n    \"Ag\",\n    \"Cd\",\n    \"Lu\",\n    \"Hf\",\n    \"Ta\",\n    \"W\",\n    \"Re\",\n    \"Os\",\n    \"Ir\",\n    \"Pt\",\n    \"Au\",\n    \"Hg\"\n  ],\n  \"f_block\": [\n    \"La\",\n    \"Ce\",\n    \"Pr\",\n    \"Nd\",\n    \"Pm\",\n    \"Sm\",\n    \"Eu\",\n    \"Gd\",\n    \"Tb\",\n    \"Dy\",\n    \"Ho\",\n    \"Er\",\n    \"Tm\",\n    \"Yb\",\n    \"Ac\",\n    \"Th\",\n    \"Pa\",\n    \"U\",\n    \"Np\",\n    \"Pu\"\n  ]\n}\n</code></pre> <p><code>VaspManager</code> also accepts an additional argument <code>magmom_per_atom_cutoff</code> which defaults to <code>0.0</code>, although I often use a value around <code>0.1</code> to avoid numerical noise and only use spin polarization in further calculations if they really need it. If this argument is passed, <code>rlx</code> calculations that finish with a magmom per atom less than this value with be re-run without spin polarization. This argument only affects <code>rlx</code> calculations, and the spin setting for following <code>static</code>, <code>bulkmod</code>, or <code>elastic</code> calculations is inferred from the final <code>rlx</code> calculation.</p>"}]}